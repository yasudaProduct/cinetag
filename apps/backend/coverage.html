
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>docs: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">cinetag-backend/src/cmd/docs/docs.go (0.0%)</option>
				
				<option value="file1">cinetag-backend/src/cmd/main.go (0.0%)</option>
				
				<option value="file2">cinetag-backend/src/cmd/migrate/main.go (0.0%)</option>
				
				<option value="file3">cinetag-backend/src/internal/db/db.go (0.0%)</option>
				
				<option value="file4">cinetag-backend/src/internal/handler/clerk_webhook_handler.go (0.0%)</option>
				
				<option value="file5">cinetag-backend/src/internal/handler/movie_handler.go (0.0%)</option>
				
				<option value="file6">cinetag-backend/src/internal/handler/tag_handler.go (48.6%)</option>
				
				<option value="file7">cinetag-backend/src/internal/handler/user_handler.go (0.0%)</option>
				
				<option value="file8">cinetag-backend/src/internal/logger/logger.go (0.0%)</option>
				
				<option value="file9">cinetag-backend/src/internal/middleware/auth.go (92.5%)</option>
				
				<option value="file10">cinetag-backend/src/internal/middleware/clerk_jwt.go (69.3%)</option>
				
				<option value="file11">cinetag-backend/src/internal/middleware/optional_auth.go (0.0%)</option>
				
				<option value="file12">cinetag-backend/src/internal/middleware/recovery.go (0.0%)</option>
				
				<option value="file13">cinetag-backend/src/internal/middleware/request_logger.go (0.0%)</option>
				
				<option value="file14">cinetag-backend/src/internal/model/movie_cache.go (0.0%)</option>
				
				<option value="file15">cinetag-backend/src/internal/model/tag.go (0.0%)</option>
				
				<option value="file16">cinetag-backend/src/internal/model/tag_follower.go (0.0%)</option>
				
				<option value="file17">cinetag-backend/src/internal/model/tag_movie.go (0.0%)</option>
				
				<option value="file18">cinetag-backend/src/internal/model/user.go (0.0%)</option>
				
				<option value="file19">cinetag-backend/src/internal/model/user_follower.go (0.0%)</option>
				
				<option value="file20">cinetag-backend/src/internal/repository/tag_follower_repository.go (0.0%)</option>
				
				<option value="file21">cinetag-backend/src/internal/repository/tag_movie_repository.go (0.0%)</option>
				
				<option value="file22">cinetag-backend/src/internal/repository/tag_repository.go (0.0%)</option>
				
				<option value="file23">cinetag-backend/src/internal/repository/user_follower_repository.go (0.0%)</option>
				
				<option value="file24">cinetag-backend/src/internal/repository/user_repository.go (0.0%)</option>
				
				<option value="file25">cinetag-backend/src/internal/seed/dev_seed.go (0.0%)</option>
				
				<option value="file26">cinetag-backend/src/internal/service/clerk_user_info_mapper.go (0.0%)</option>
				
				<option value="file27">cinetag-backend/src/internal/service/display_id.go (100.0%)</option>
				
				<option value="file28">cinetag-backend/src/internal/service/movie_service.go (0.0%)</option>
				
				<option value="file29">cinetag-backend/src/internal/service/tag_service.go (39.5%)</option>
				
				<option value="file30">cinetag-backend/src/internal/service/user_service.go (17.8%)</option>
				
				<option value="file31">cinetag-backend/src/internal/testutil/fakes_repository.go (0.0%)</option>
				
				<option value="file32">cinetag-backend/src/internal/testutil/fakes_service.go (0.0%)</option>
				
				<option value="file33">cinetag-backend/src/internal/testutil/http.go (0.0%)</option>
				
				<option value="file34">cinetag-backend/src/internal/testutil/json.go (0.0%)</option>
				
				<option value="file35">cinetag-backend/src/router/dependencies.go (0.0%)</option>
				
				<option value="file36">cinetag-backend/src/router/router.go (0.0%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">not covered</span>
				<span class="cov8">covered</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">// Package docs Code generated by swaggo/swag. DO NOT EDIT
package docs

import "github.com/swaggo/swag"

const docTemplate = `{
    "schemes": {{ marshal .Schemes }},
    "swagger": "2.0",
    "info": {
        "description": "{{escape .Description}}",
        "title": "{{.Title}}",
        "contact": {},
        "version": "{{.Version}}"
    },
    "host": "{{.Host}}",
    "basePath": "{{.BasePath}}",
    "paths": {}
}`

// SwaggerInfo holds exported Swagger Info so clients can modify it
var SwaggerInfo = &amp;swag.Spec{
        Version:          "",
        Host:             "",
        BasePath:         "",
        Schemes:          []string{},
        Title:            "",
        Description:      "",
        InfoInstanceName: "swagger",
        SwaggerTemplate:  docTemplate,
        LeftDelim:        "{{",
        RightDelim:       "}}",
}

func init() <span class="cov0" title="0">{
        swag.Register(SwaggerInfo.InstanceName(), SwaggerInfo)
}</span>
</pre>
		
		<pre class="file" id="file1" style="display: none">package main

import (
        "log"
        "os"

        docs "cinetag-backend/src/cmd/docs"
        appRouter "cinetag-backend/src/router"
)

func main() <span class="cov0" title="0">{
        // ポート番号の取得
        port := os.Getenv("PORT")
        if port == "" </span><span class="cov0" title="0">{
                port = "8080"
        }</span>

        // Swagger メタ情報の設定
        <span class="cov0" title="0">docs.SwaggerInfo.Host = "localhost:" + port
        docs.SwaggerInfo.BasePath = "/api/v1"

        // ルーターの初期化
        router := appRouter.NewRouter()

        // サーバーの起動
        if err := router.Run(":" + port); err != nil </span><span class="cov0" title="0">{
                log.Fatalf("failed to start server: %v", err)
        }</span>
}
</pre>
		
		<pre class="file" id="file2" style="display: none">package main

import (
        "log"
        "os"
        "strings"

        "cinetag-backend/src/internal/db"
        "cinetag-backend/src/internal/model"
        "cinetag-backend/src/internal/seed"

        "gorm.io/gorm"
)

// resetSchemaIfEnabled は、開発環境でのみ「全テーブル削除（public スキーマ再作成）」を実行します。
//
// 本番での誤実行を防ぐため、ENV=develop の場合のみ実行します。
func resetSchemaIfEnabled(database *gorm.DB) <span class="cov0" title="0">{
        env := strings.TrimSpace(strings.ToLower(os.Getenv("ENV")))
        if env != "develop" </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov0" title="0">log.Println("ENV=develop: resetting schema (DROP SCHEMA public CASCADE; CREATE SCHEMA public;)")
        if err := database.Exec(`DROP SCHEMA IF EXISTS public CASCADE; CREATE SCHEMA public;`).Error; err != nil </span><span class="cov0" title="0">{
                log.Fatalf("failed to reset schema: %v", err)
        }</span>
}

// このコマンドはデータベースマイグレーション専用のエントリーポイントです。
// アプリケーション本体とは別に実行し、スキーマ更新のみを行います。
func main() <span class="cov0" title="0">{
        database := db.NewDB()

        resetSchemaIfEnabled(database)

        if err := database.AutoMigrate(
                &amp;model.User{},
                &amp;model.Tag{},
                &amp;model.TagMovie{},
                &amp;model.TagFollower{},
                &amp;model.UserFollower{},
                &amp;model.MovieCache{},
        ); err != nil </span><span class="cov0" title="0">{
                log.Fatalf("failed to migrate database: %v", err)
        }</span>

        <span class="cov0" title="0">if err := seed.SeedDevelop(database); err != nil </span><span class="cov0" title="0">{
                log.Fatalf("failed to seed database: %v", err)
        }</span>

        <span class="cov0" title="0">log.Println("migration completed successfully")</span>
}
</pre>
		
		<pre class="file" id="file3" style="display: none">package db

import (
        "log"
        "os"

        "github.com/joho/godotenv"
        "gorm.io/driver/postgres"
        "gorm.io/gorm"
)

func init() <span class="cov0" title="0">{
        err := godotenv.Load()
        if err != nil </span><span class="cov0" title="0">{
                log.Println(".envファイルの情報が取得できません")
        }</span>
}

// NewDB はアプリケーションで利用する *gorm.DB を初期化して返します。
// この関数は「接続の確立」のみに責務を持ち、マイグレーションは別コマンドで実行します。
func NewDB() *gorm.DB <span class="cov0" title="0">{
        dsn := os.Getenv("DATABASE_URL")
        if dsn == "" </span><span class="cov0" title="0">{
                log.Fatal("DATABASE_URL is not set")
        }</span>

        <span class="cov0" title="0">db, err := gorm.Open(postgres.Open(dsn), &amp;gorm.Config{})
        if err != nil </span><span class="cov0" title="0">{
                log.Fatalf("failed to connect database: %v", err)
        }</span>

        <span class="cov0" title="0">return db</span>
}
</pre>
		
		<pre class="file" id="file4" style="display: none">package handler

import (
        "encoding/json"
        "log/slog"
        "net/http"

        "cinetag-backend/src/internal/middleware"
        "cinetag-backend/src/internal/service"

        "github.com/gin-gonic/gin"
)

// Clerk Webhook の共通ペイロードを表します。
// data の中身はイベントタイプにより異なるため RawMessage で受け取ります。
// https://clerk.com/docs/guides/development/webhooks/overview#payload-structure
type clerkWebhookEvent struct {
        Type string          `json:"type"`
        Data json.RawMessage `json:"data"`
}

// Clerk の user.created Webhook の data 部分を表します。
type clerkUserCreatedData struct {
        ID             string `json:"id"`
        Username       string `json:"username"`
        FirstName      string `json:"first_name"`
        LastName       string `json:"last_name"`
        ImageURL       string `json:"image_url"`
        EmailAddresses []struct {
                EmailAddress string `json:"email_address"`
        } `json:"email_addresses"`
}

// Clerk の user.deleted Webhook の data 部分を表します。
type clerkUserDeletedData struct {
        ID string `json:"id"`
}

// Clerk Webhook を処理するハンドラーです。
type ClerkWebhookHandler struct {
        logger      *slog.Logger
        userService service.UserService
}

// ClerkWebhookHandler を初期化して返します。
func NewClerkWebhookHandler(logger *slog.Logger, userService service.UserService) *ClerkWebhookHandler <span class="cov0" title="0">{
        return &amp;ClerkWebhookHandler{
                logger:      logger,
                userService: userService,
        }
}</span>

// POST /api/v1/clerk/webhook を処理します。
// 現時点では svix 署名検証ロジックは未実装です。
// TODO: svix の署名検証を追加し、Clerk からの正当なリクエストのみを受け付ける。
func (h *ClerkWebhookHandler) HandleWebhook(c *gin.Context) <span class="cov0" title="0">{

        requestID := middleware.GetRequestID(c)

        // ペイロードをバインド
        var event clerkWebhookEvent
        if err := c.ShouldBindJSON(&amp;event); err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, gin.H{
                        "error": "invalid webhook payload",
                })
                return
        }</span>

        // 開始ログ（INFO）
        <span class="cov0" title="0">h.logger.Info("handler.HandleWebhook started",
                slog.String("request_id", requestID),
                slog.String("event_type", event.Type),
        )

        switch event.Type </span>{
        case "user.created":<span class="cov0" title="0">
                var data clerkUserCreatedData
                if err := json.Unmarshal(event.Data, &amp;data); err != nil </span><span class="cov0" title="0">{
                        c.JSON(http.StatusBadRequest, gin.H{
                                "error": "invalid webhook data",
                        })
                        return
                }</span>

                // デバッグログ（DEBUG）
                <span class="cov0" title="0">h.logger.Debug("handler.HandleWebhook user.created",
                        slog.String("request_id", requestID),
                        slog.String("clerk_user_id", data.ID),
                        slog.String("username", data.Username),
                        slog.String("first_name", data.FirstName),
                        slog.String("last_name", data.LastName),
                        slog.String("image_url", data.ImageURL),
                )

                email := ""
                if len(data.EmailAddresses) &gt; 0 </span><span class="cov0" title="0">{
                        // TODO: 複数のメールアドレスを無効化できる？
                        email = data.EmailAddresses[0].EmailAddress
                }</span>

                // ImageURL をオプショナルな *string 型に変換する。
                // 空文字列の場合は nil を設定し、値がある場合はローカル変数にコピーしてから
                // そのアドレスを取得する。これにより、構造体フィールドへの直接ポインタ取得を
                // 避け、エスケープ解析の最適化と独立性を確保する。
                <span class="cov0" title="0">var avatarURL *string
                if data.ImageURL != "" </span><span class="cov0" title="0">{
                        url := data.ImageURL
                        avatarURL = &amp;url
                }</span>

                // clerkUserInfo を作成
                <span class="cov0" title="0">clerkUser, err := service.NewClerkUserInfoFromWebhook(
                        data.ID,
                        email,
                        data.FirstName,
                        data.LastName,
                        avatarURL,
                )
                if err != nil </span><span class="cov0" title="0">{
                        c.JSON(http.StatusInternalServerError, gin.H{
                                "error": "failed to sync user",
                        })
                        return
                }</span>

                <span class="cov0" title="0">if _, err := h.userService.EnsureUser(c.Request.Context(), clerkUser); err != nil </span><span class="cov0" title="0">{
                        c.JSON(http.StatusInternalServerError, gin.H{
                                "error": "failed to sync user",
                        })
                        return
                }</span>

                <span class="cov0" title="0">c.Status(http.StatusOK)
                return</span>

        case "user.deleted":<span class="cov0" title="0">
                var data clerkUserDeletedData
                if err := json.Unmarshal(event.Data, &amp;data); err != nil </span><span class="cov0" title="0">{
                        c.JSON(http.StatusBadRequest, gin.H{
                                "error": "invalid webhook data",
                        })
                        return
                }</span>

                // デバッグログ（DEBUG）
                <span class="cov0" title="0">h.logger.Debug("handler.HandleWebhook user.deleted",
                        slog.String("request_id", requestID),
                        slog.String("clerk_user_id", data.ID),
                )

                // ユーザーが存在しない場合は成功とする
                u, err := h.userService.FindUserByClerkUserID(c.Request.Context(), data.ID)
                if err != nil </span><span class="cov0" title="0">{
                        if err == service.ErrUserNotFound </span><span class="cov0" title="0">{
                                c.Status(http.StatusOK)
                                return
                        }</span>
                        <span class="cov0" title="0">c.JSON(http.StatusInternalServerError, gin.H{
                                "error": "failed to resolve user by clerk user id",
                        })
                        return</span>
                }

                // ユーザー削除
                <span class="cov0" title="0">if err := h.userService.DeactivateUser(c.Request.Context(), u.ID); err != nil </span><span class="cov0" title="0">{
                        c.JSON(http.StatusInternalServerError, gin.H{
                                "error": "failed to deactivate user",
                        })
                        return
                }</span>

                <span class="cov0" title="0">c.Status(http.StatusOK)
                return</span>

        default:<span class="cov0" title="0">
                // 他のイベントタイプは無視
                c.Status(http.StatusOK)
                return</span>
        }
}
</pre>
		
		<pre class="file" id="file5" style="display: none">package handler

import (
        "log/slog"
        "net/http"
        "strings"

        "cinetag-backend/src/internal/service"

        "github.com/gin-gonic/gin"
)

// 映画検索等のHTTPハンドラです。
type MovieHandler struct {
        logger       *slog.Logger
        movieService service.MovieService
}

func NewMovieHandler(logger *slog.Logger, movieService service.MovieService) *MovieHandler <span class="cov0" title="0">{
        return &amp;MovieHandler{
                logger:       logger,
                movieService: movieService,
        }
}</span>

// TMDB 検索結果を返します。
// GET /api/v1/movies/search?q={query}&amp;page={page}
func (h *MovieHandler) SearchMovies(c *gin.Context) <span class="cov0" title="0">{
        q := strings.TrimSpace(c.Query("q"))
        page := parseIntDefault(c.Query("page"), 1)

        items, total, err := h.movieService.SearchMovies(c.Request.Context(), q, page)
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusInternalServerError, gin.H{"error": "failed to search movies"})
                return
        }</span>

        <span class="cov0" title="0">c.JSON(http.StatusOK, gin.H{
                "items":       items,
                "page":        page,
                "total_count": total,
        })</span>
}
</pre>
		
		<pre class="file" id="file6" style="display: none">package handler

import (
        "errors"
        "log/slog"
        "net/http"
        "strconv"

        "cinetag-backend/src/internal/middleware"
        "cinetag-backend/src/internal/model"
        "cinetag-backend/src/internal/service"

        "github.com/gin-gonic/gin"
)

// タグ関連の HTTP ハンドラー。
type TagHandler struct {
        logger     *slog.Logger
        tagService service.TagService
}

// TagHandler を初期化して返す。
func NewTagHandler(logger *slog.Logger, tagService service.TagService) *TagHandler <span class="cov8" title="1">{
        return &amp;TagHandler{
                logger:     logger,
                tagService: tagService,
        }
}</span>

// タグ作成リクエストボディの構造。
// user_id はクライアントからは受け取らず、AuthMiddleware によりコンテキストに設定された認証済みユーザー情報から取得する。
type createTagRequest struct {
        Title          string  `json:"title" binding:"required"`
        Description    *string `json:"description"`
        CoverImageURL  *string `json:"cover_image_url"`
        IsPublic       *bool   `json:"is_public"`
        AddMoviePolicy *string `json:"add_movie_policy"`
}

// タグに映画を追加するリクエストボディの構造。
type addTagMovieRequest struct {
        TmdbMovieID int     `json:"tmdb_movie_id" binding:"required"`
        Note        *string `json:"note"`
        Position    int     `json:"position"`
}

// タグのメタ情報を更新するリクエストボディの構造。
type updateTagRequest struct {
        Title          *string  `json:"title"`
        Description    **string `json:"description"`
        CoverImageURL  **string `json:"cover_image_url"`
        IsPublic       *bool    `json:"is_public"`
        AddMoviePolicy *string  `json:"add_movie_policy"`
}

// タグ詳細を取得する。
// GET /api/v1/tags/:tagId
func (h *TagHandler) GetTagDetail(c *gin.Context) <span class="cov8" title="1">{
        tagID := c.Param("tagId")

        var viewerUserID *string
        if userVal, ok := c.Get("user"); ok </span><span class="cov8" title="1">{
                if user, ok2 := userVal.(*model.User); ok2 &amp;&amp; user != nil &amp;&amp; user.ID != "" </span><span class="cov8" title="1">{
                        id := user.ID
                        viewerUserID = &amp;id
                }</span>
        }

        // タグ詳細を取得する。
        <span class="cov8" title="1">out, err := h.tagService.GetTagDetail(c.Request.Context(), tagID, viewerUserID)
        if err != nil </span><span class="cov0" title="0">{
                switch </span>{
                case errors.Is(err, service.ErrTagNotFound):<span class="cov0" title="0">
                        c.JSON(http.StatusNotFound, gin.H{"error": "tag not found"})</span>
                case errors.Is(err, service.ErrTagPermissionDenied):<span class="cov0" title="0">
                        c.JSON(http.StatusForbidden, gin.H{"error": "forbidden"})</span>
                default:<span class="cov0" title="0">
                        c.JSON(http.StatusInternalServerError, gin.H{"error": "failed to get tag detail"})</span>
                }
                <span class="cov0" title="0">return</span>
        }

        <span class="cov8" title="1">c.JSON(http.StatusOK, out)</span>
}

// タグ内の映画一覧を取得する。
func (h *TagHandler) ListTagMovies(c *gin.Context) <span class="cov0" title="0">{
        tagID := c.Param("tagId")

        page := parseIntDefault(c.Query("page"), 1)
        pageSize := parseIntDefault(c.Query("page_size"), 50)

        var viewerUserID *string
        if userVal, ok := c.Get("user"); ok </span><span class="cov0" title="0">{
                if user, ok2 := userVal.(*model.User); ok2 &amp;&amp; user != nil &amp;&amp; user.ID != "" </span><span class="cov0" title="0">{
                        id := user.ID
                        viewerUserID = &amp;id
                }</span>
        }

        <span class="cov0" title="0">items, total, err := h.tagService.ListTagMovies(c.Request.Context(), tagID, viewerUserID, page, pageSize)
        if err != nil </span><span class="cov0" title="0">{
                switch </span>{
                case errors.Is(err, service.ErrTagNotFound):<span class="cov0" title="0">
                        c.JSON(http.StatusNotFound, gin.H{"error": "tag not found"})</span>
                case errors.Is(err, service.ErrTagPermissionDenied):<span class="cov0" title="0">
                        c.JSON(http.StatusForbidden, gin.H{"error": "forbidden"})</span>
                default:<span class="cov0" title="0">
                        c.JSON(http.StatusInternalServerError, gin.H{"error": "failed to list tag movies"})</span>
                }
                <span class="cov0" title="0">return</span>
        }

        <span class="cov0" title="0">c.JSON(http.StatusOK, gin.H{
                "items":       items,
                "page":        page,
                "page_size":   pageSize,
                "total_count": total,
        })</span>
}

// UpdateTag はタグのメタ情報を更新します（作成者のみ）。
func (h *TagHandler) UpdateTag(c *gin.Context) <span class="cov8" title="1">{
        tagID := c.Param("tagId")

        // AuthMiddleware によってコンテキストに設定されたユーザー情報を取得
        userVal, exists := c.Get("user")
        if !exists </span><span class="cov8" title="1">{
                // ユーザー情報がない場合、401 Unauthorizedを返す
                c.JSON(http.StatusUnauthorized, gin.H{"error": "unauthorized"})
                return
        }</span>
        <span class="cov8" title="1">user, ok := userVal.(*model.User)
        if !ok || user == nil </span><span class="cov0" title="0">{
                // ユーザー情報が無効な場合、500 Internal Server Errorを返す
                c.JSON(http.StatusInternalServerError, gin.H{"error": "invalid user in context"})
                return
        }</span>

        <span class="cov8" title="1">var req updateTagRequest
        if err := c.ShouldBindJSON(&amp;req); err != nil </span><span class="cov0" title="0">{
                // リクエストボディが無効な場合、400 Bad Requestを返す
                c.JSON(http.StatusBadRequest, gin.H{"error": "invalid request body"})
                return
        }</span>

        // タグを更新する。
        <span class="cov8" title="1">out, err := h.tagService.UpdateTag(c.Request.Context(), tagID, user.ID, service.UpdateTagPatch{
                Title:          req.Title,
                Description:    req.Description,
                CoverImageURL:  req.CoverImageURL,
                IsPublic:       req.IsPublic,
                AddMoviePolicy: req.AddMoviePolicy,
        })
        if err != nil </span><span class="cov8" title="1">{
                switch </span>{
                case errors.Is(err, service.ErrTagNotFound):<span class="cov8" title="1">
                        c.JSON(http.StatusNotFound, gin.H{"error": "tag not found"})</span>
                case errors.Is(err, service.ErrTagPermissionDenied):<span class="cov8" title="1">
                        c.JSON(http.StatusForbidden, gin.H{"error": "forbidden"})</span>
                default:<span class="cov0" title="0">
                        c.JSON(http.StatusInternalServerError, gin.H{"error": "failed to update tag"})</span>
                }
                <span class="cov8" title="1">return</span>
        }

        <span class="cov8" title="1">c.JSON(http.StatusOK, out)</span>
}

// @Summary 公開タグ一覧を取得
// @Description 公開タグ一覧を取得
// @Tags tags
// @Accept json
// @Produce json
// @Param q query string false "タイトル検索用キーワード"
// @Param sort query string false "popular / recent / movie_count"
// @Param page query int false "ページ番号"
// @Param page_size query int false "1ページあたり件数"
// @Success 200 {object}
// @Failure 500 {object}
// @Router /api/v1/tags [get]
func (h *TagHandler) ListPublicTags(c *gin.Context) <span class="cov8" title="1">{
        q := c.Query("q")
        sort := c.Query("sort")

        page := parseIntDefault(c.Query("page"), 1)
        pageSize := parseIntDefault(c.Query("page_size"), 20)

        items, total, err := h.tagService.ListPublicTags(c.Request.Context(), q, sort, page, pageSize)
        if err != nil </span><span class="cov8" title="1">{
                c.JSON(http.StatusInternalServerError, gin.H{
                        "error": "failed to list tags",
                })
                return
        }</span>

        <span class="cov8" title="1">c.JSON(http.StatusOK, gin.H{
                "items":       items,
                "page":        page,
                "page_size":   pageSize,
                "total_count": total,
        })</span>
}

// @Summary タグを作成
// @Description タグを作成
// @Tags tags
// @Accept json
// @Produce json
// @Param request body createTagRequest true "タグ作成リクエスト"
// @Success 201 {object}
// @Failure 400 {object}
// @Failure 500 {object}
// @Router api/v1/tags [post]
func (h *TagHandler) CreateTag(c *gin.Context) <span class="cov8" title="1">{
        var req createTagRequest
        if err := c.ShouldBindJSON(&amp;req); err != nil </span><span class="cov8" title="1">{
                c.JSON(http.StatusBadRequest, gin.H{
                        "error": "invalid request body",
                })
                return
        }</span>

        // AuthMiddleware によってコンテキストに設定されたユーザー情報を取得
        <span class="cov8" title="1">userVal, exists := c.Get("user")
        if !exists </span><span class="cov8" title="1">{
                c.JSON(http.StatusUnauthorized, gin.H{
                        "error": "unauthorized",
                })
                return
        }</span>
        <span class="cov8" title="1">user, ok := userVal.(*model.User)
        if !ok || user == nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusInternalServerError, gin.H{
                        "error": "invalid user in context",
                })
                return
        }</span>

        // シンプルなバリデーション（タイトル長・説明長）
        <span class="cov8" title="1">if l := len([]rune(req.Title)); l == 0 || l &gt; 100 </span><span class="cov8" title="1">{
                c.JSON(http.StatusBadRequest, gin.H{
                        "error": "title must be between 1 and 100 characters",
                })
                return
        }</span>
        <span class="cov8" title="1">if req.Description != nil </span><span class="cov8" title="1">{
                if l := len([]rune(*req.Description)); l &gt; 500 </span><span class="cov8" title="1">{
                        c.JSON(http.StatusBadRequest, gin.H{
                                "error": "description must be 500 characters or less",
                        })
                        return
                }</span>
        }

        <span class="cov8" title="1">tag, err := h.tagService.CreateTag(c.Request.Context(), service.CreateTagInput{
                UserID:         user.ID,
                Title:          req.Title,
                Description:    req.Description,
                CoverImageURL:  req.CoverImageURL,
                IsPublic:       req.IsPublic,
                AddMoviePolicy: req.AddMoviePolicy,
        })
        if err != nil </span><span class="cov8" title="1">{
                c.JSON(http.StatusInternalServerError, gin.H{
                        "error": "failed to create tag",
                })
                return
        }</span>

        // レスポンスは api-spec に合わせて必要なフィールドのみ返す
        <span class="cov8" title="1">c.JSON(http.StatusCreated, gin.H{
                "id":               tag.ID,
                "title":            tag.Title,
                "description":      tag.Description,
                "cover_image_url":  tag.CoverImageURL,
                "is_public":        tag.IsPublic,
                "add_movie_policy": tag.AddMoviePolicy,
                "movie_count":      tag.MovieCount,
                "follower_count":   tag.FollowerCount,
                "created_at":       tag.CreatedAt,
                "updated_at":       tag.UpdatedAt,
        })</span>
}

// @name AddMovieToTag
// @Summary タグに映画を追加
// @Description タグに映画を追加
// @Tags tags
// @Accept json
// @Produce json
// @Param tagId path string true "タグID"
// @Param request body addTagMovieRequest true "映画追加リクエスト"
func (h *TagHandler) AddMovieToTag(c *gin.Context) <span class="cov8" title="1">{
        tagID := c.Param("tagId")
        requestID := middleware.GetRequestID(c)

        // 開始ログ（INFO）
        attrs := []any{
                slog.String("request_id", requestID),
                slog.String("tag_id", tagID),
        }

        // 認証済みの場合は user_id も含める
        if userVal, ok := c.Get("user"); ok </span><span class="cov8" title="1">{
                if user, ok2 := userVal.(*model.User); ok2 &amp;&amp; user != nil </span><span class="cov8" title="1">{
                        attrs = append(attrs, slog.String("user_id", user.ID))
                }</span>
        }

        <span class="cov8" title="1">h.logger.Info("handler.AddMovieToTag started", attrs...)

        var req addTagMovieRequest
        if err := c.ShouldBindJSON(&amp;req); err != nil </span><span class="cov8" title="1">{
                c.JSON(http.StatusBadRequest, gin.H{
                        "error": "invalid request body",
                })
                return
        }</span>
        <span class="cov8" title="1">if req.TmdbMovieID &lt;= 0 </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, gin.H{
                        "error": "tmdb_movie_id must be a positive integer",
                })
                return
        }</span>
        <span class="cov8" title="1">if req.Position &lt; 0 </span><span class="cov8" title="1">{
                c.JSON(http.StatusBadRequest, gin.H{
                        "error": "position must be 0 or greater",
                })
                return
        }</span>

        <span class="cov8" title="1">userVal, exists := c.Get("user")
        if !exists </span><span class="cov8" title="1">{
                c.JSON(http.StatusUnauthorized, gin.H{
                        "error": "unauthorized",
                })
                return
        }</span>
        <span class="cov8" title="1">user, ok := userVal.(*model.User)
        if !ok || user == nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusInternalServerError, gin.H{
                        "error": "invalid user in context",
                })
                return
        }</span>

        // タグに映画を追加する。
        <span class="cov8" title="1">tagMovie, err := h.tagService.AddMovieToTag(c.Request.Context(), service.AddMovieToTagInput{
                TagID:       tagID,
                UserID:      user.ID,
                TmdbMovieID: req.TmdbMovieID,
                Note:        req.Note,
                Position:    req.Position,
        })
        if err != nil </span><span class="cov8" title="1">{
                switch </span>{
                case errors.Is(err, service.ErrTagNotFound):<span class="cov8" title="1">
                        c.JSON(http.StatusNotFound, gin.H{"error": "tag not found"})</span>
                case errors.Is(err, service.ErrTagPermissionDenied):<span class="cov8" title="1">
                        c.JSON(http.StatusForbidden, gin.H{"error": "forbidden"})</span>
                case errors.Is(err, service.ErrTagMovieAlreadyExists):<span class="cov8" title="1">
                        c.JSON(http.StatusConflict, gin.H{"error": "movie already added to tag"})</span>
                default:<span class="cov8" title="1">
                        c.JSON(http.StatusInternalServerError, gin.H{"error": "failed to add movie to tag"})</span>
                }
                <span class="cov8" title="1">return</span>
        }

        <span class="cov8" title="1">c.JSON(http.StatusCreated, tagMovie)</span>
}

// RemoveMovieFromTag はタグから映画を削除します。
func (h *TagHandler) RemoveMovieFromTag(c *gin.Context) <span class="cov8" title="1">{
        tagMovieID := c.Param("tagMovieId")

        userVal, exists := c.Get("user")
        if !exists </span><span class="cov8" title="1">{
                c.JSON(http.StatusUnauthorized, gin.H{
                        "error": "unauthorized",
                })
                return
        }</span>
        <span class="cov8" title="1">user, ok := userVal.(*model.User)
        if !ok || user == nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusInternalServerError, gin.H{
                        "error": "invalid user in context",
                })
                return
        }</span>

        <span class="cov8" title="1">err := h.tagService.RemoveMovieFromTag(c.Request.Context(), tagMovieID, user.ID)
        if err != nil </span><span class="cov8" title="1">{
                switch </span>{
                case errors.Is(err, service.ErrTagMovieNotFound):<span class="cov8" title="1">
                        c.JSON(http.StatusNotFound, gin.H{"error": "tag movie not found"})</span>
                case errors.Is(err, service.ErrTagNotFound):<span class="cov0" title="0">
                        c.JSON(http.StatusNotFound, gin.H{"error": "tag not found"})</span>
                case errors.Is(err, service.ErrTagPermissionDenied):<span class="cov8" title="1">
                        c.JSON(http.StatusForbidden, gin.H{"error": "forbidden"})</span>
                default:<span class="cov8" title="1">
                        c.JSON(http.StatusInternalServerError, gin.H{"error": "failed to remove movie from tag"})</span>
                }
                <span class="cov8" title="1">return</span>
        }

        <span class="cov8" title="1">c.Status(http.StatusNoContent)</span>
}

// FollowTag はタグをフォローします。
// POST /api/v1/tags/:tagId/follow
func (h *TagHandler) FollowTag(c *gin.Context) <span class="cov0" title="0">{
        tagID := c.Param("tagId")

        userVal, exists := c.Get("user")
        if !exists </span><span class="cov0" title="0">{
                c.JSON(http.StatusUnauthorized, gin.H{"error": "unauthorized"})
                return
        }</span>
        <span class="cov0" title="0">user, ok := userVal.(*model.User)
        if !ok || user == nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusInternalServerError, gin.H{"error": "invalid user in context"})
                return
        }</span>

        <span class="cov0" title="0">err := h.tagService.FollowTag(c.Request.Context(), tagID, user.ID)
        if err != nil </span><span class="cov0" title="0">{
                switch </span>{
                case errors.Is(err, service.ErrTagNotFound):<span class="cov0" title="0">
                        c.JSON(http.StatusNotFound, gin.H{"error": "tag not found"})</span>
                case errors.Is(err, service.ErrTagPermissionDenied):<span class="cov0" title="0">
                        c.JSON(http.StatusForbidden, gin.H{"error": "forbidden"})</span>
                case errors.Is(err, service.ErrAlreadyFollowingTag):<span class="cov0" title="0">
                        c.JSON(http.StatusConflict, gin.H{"error": "already following"})</span>
                default:<span class="cov0" title="0">
                        c.JSON(http.StatusInternalServerError, gin.H{"error": "failed to follow tag"})</span>
                }
                <span class="cov0" title="0">return</span>
        }

        <span class="cov0" title="0">c.JSON(http.StatusOK, gin.H{"message": "successfully followed"})</span>
}

// UnfollowTag はタグのフォローを解除します。
// DELETE /api/v1/tags/:tagId/follow
func (h *TagHandler) UnfollowTag(c *gin.Context) <span class="cov0" title="0">{
        tagID := c.Param("tagId")

        userVal, exists := c.Get("user")
        if !exists </span><span class="cov0" title="0">{
                c.JSON(http.StatusUnauthorized, gin.H{"error": "unauthorized"})
                return
        }</span>
        <span class="cov0" title="0">user, ok := userVal.(*model.User)
        if !ok || user == nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusInternalServerError, gin.H{"error": "invalid user in context"})
                return
        }</span>

        <span class="cov0" title="0">err := h.tagService.UnfollowTag(c.Request.Context(), tagID, user.ID)
        if err != nil </span><span class="cov0" title="0">{
                switch </span>{
                case errors.Is(err, service.ErrTagNotFound):<span class="cov0" title="0">
                        c.JSON(http.StatusNotFound, gin.H{"error": "tag not found"})</span>
                case errors.Is(err, service.ErrNotFollowingTag):<span class="cov0" title="0">
                        c.JSON(http.StatusConflict, gin.H{"error": "not following"})</span>
                default:<span class="cov0" title="0">
                        c.JSON(http.StatusInternalServerError, gin.H{"error": "failed to unfollow tag"})</span>
                }
                <span class="cov0" title="0">return</span>
        }

        <span class="cov0" title="0">c.JSON(http.StatusOK, gin.H{"message": "successfully unfollowed"})</span>
}

// GetTagFollowStatus はユーザーがタグをフォローしているかチェックします。
// GET /api/v1/tags/:tagId/follow-status
func (h *TagHandler) GetTagFollowStatus(c *gin.Context) <span class="cov0" title="0">{
        tagID := c.Param("tagId")

        userVal, exists := c.Get("user")
        if !exists </span><span class="cov0" title="0">{
                c.JSON(http.StatusUnauthorized, gin.H{"error": "unauthorized"})
                return
        }</span>
        <span class="cov0" title="0">user, ok := userVal.(*model.User)
        if !ok || user == nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusInternalServerError, gin.H{"error": "invalid user in context"})
                return
        }</span>

        <span class="cov0" title="0">isFollowing, err := h.tagService.IsFollowingTag(c.Request.Context(), tagID, user.ID)
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusInternalServerError, gin.H{"error": "failed to get follow status"})
                return
        }</span>

        <span class="cov0" title="0">c.JSON(http.StatusOK, gin.H{"is_following": isFollowing})</span>
}

// ListTagFollowers はタグのフォロワー一覧を取得します。
// GET /api/v1/tags/:tagId/followers
func (h *TagHandler) ListTagFollowers(c *gin.Context) <span class="cov0" title="0">{
        tagID := c.Param("tagId")

        page := parseIntDefault(c.Query("page"), 1)
        pageSize := parseIntDefault(c.Query("page_size"), 20)

        users, total, err := h.tagService.ListTagFollowers(c.Request.Context(), tagID, page, pageSize)
        if err != nil </span><span class="cov0" title="0">{
                switch </span>{
                case errors.Is(err, service.ErrTagNotFound):<span class="cov0" title="0">
                        c.JSON(http.StatusNotFound, gin.H{"error": "tag not found"})</span>
                default:<span class="cov0" title="0">
                        c.JSON(http.StatusInternalServerError, gin.H{"error": "failed to list tag followers"})</span>
                }
                <span class="cov0" title="0">return</span>
        }

        // ユーザー情報をレスポンス用に変換
        <span class="cov0" title="0">items := make([]gin.H, 0, len(users))
        for _, u := range users </span><span class="cov0" title="0">{
                items = append(items, gin.H{
                        "id":           u.ID,
                        "display_id":   u.DisplayID,
                        "display_name": u.DisplayName,
                        "avatar_url":   u.AvatarURL,
                })
        }</span>

        <span class="cov0" title="0">c.JSON(http.StatusOK, gin.H{
                "items":       items,
                "page":        page,
                "page_size":   pageSize,
                "total_count": total,
        })</span>
}

// ListFollowingTags はログインユーザーがフォローしているタグ一覧を取得します。
// GET /api/v1/me/following-tags
func (h *TagHandler) ListFollowingTags(c *gin.Context) <span class="cov0" title="0">{
        userVal, exists := c.Get("user")
        if !exists </span><span class="cov0" title="0">{
                c.JSON(http.StatusUnauthorized, gin.H{"error": "unauthorized"})
                return
        }</span>
        <span class="cov0" title="0">user, ok := userVal.(*model.User)
        if !ok || user == nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusInternalServerError, gin.H{"error": "invalid user in context"})
                return
        }</span>

        <span class="cov0" title="0">page := parseIntDefault(c.Query("page"), 1)
        pageSize := parseIntDefault(c.Query("page_size"), 20)

        items, total, err := h.tagService.ListFollowingTags(c.Request.Context(), user.ID, page, pageSize)
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusInternalServerError, gin.H{"error": "failed to list following tags"})
                return
        }</span>

        <span class="cov0" title="0">c.JSON(http.StatusOK, gin.H{
                "items":       items,
                "page":        page,
                "page_size":   pageSize,
                "total_count": total,
        })</span>
}

func parseIntDefault(s string, def int) int <span class="cov8" title="1">{
        if s == "" </span><span class="cov8" title="1">{
                return def
        }</span>
        <span class="cov8" title="1">v, err := strconv.Atoi(s)
        if err != nil </span><span class="cov8" title="1">{
                return def
        }</span>
        <span class="cov0" title="0">return v</span>
}
</pre>
		
		<pre class="file" id="file7" style="display: none">package handler

import (
        "errors"
        "log/slog"
        "net/http"
        "strconv"

        "cinetag-backend/src/internal/middleware"
        "cinetag-backend/src/internal/model"
        "cinetag-backend/src/internal/service"

        "github.com/gin-gonic/gin"
)

// ユーザー関連のHTTPハンドラー。
type UserHandler struct {
        logger      *slog.Logger
        userService service.UserService
        tagService  service.TagService
}

// UserHandler を生成する。
func NewUserHandler(logger *slog.Logger, userService service.UserService, tagService service.TagService) *UserHandler <span class="cov0" title="0">{
        return &amp;UserHandler{
                logger:      logger,
                userService: userService,
                tagService:  tagService,
        }
}</span>

// ユーザープロフィールのレスポンス形式。
type UserProfileResponse struct {
        ID          string  `json:"id"`
        DisplayID   string  `json:"display_id"`
        DisplayName string  `json:"display_name"`
        AvatarURL   *string `json:"avatar_url,omitempty"`
        Bio         *string `json:"bio,omitempty"`
}

// 認証済みユーザー自身の情報を返す。
// GET /api/v1/users/me
func (h *UserHandler) GetMe(c *gin.Context) <span class="cov0" title="0">{
        userRaw, exists := c.Get("user")
        if !exists </span><span class="cov0" title="0">{
                c.JSON(http.StatusUnauthorized, gin.H{"error": "unauthorized"})
                return
        }</span>

        <span class="cov0" title="0">user, ok := userRaw.(*model.User)
        if !ok || user == nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusInternalServerError, gin.H{"error": "invalid user context"})
                return
        }</span>

        <span class="cov0" title="0">c.JSON(http.StatusOK, UserProfileResponse{
                ID:          user.ID,
                DisplayID:   user.DisplayID,
                DisplayName: user.DisplayName,
                AvatarURL:   user.AvatarURL,
                Bio:         user.Bio,
        })</span>
}

// display_id からユーザー情報を取得する。
// GET /api/v1/users/:displayId
func (h *UserHandler) GetUserByDisplayID(c *gin.Context) <span class="cov0" title="0">{
        displayID := c.Param("displayId")
        if displayID == "" </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, gin.H{"error": "display_id is required"})
                return
        }</span>

        <span class="cov0" title="0">user, err := h.userService.GetUserByDisplayID(c.Request.Context(), displayID)
        if err != nil </span><span class="cov0" title="0">{
                if errors.Is(err, service.ErrUserNotFound) </span><span class="cov0" title="0">{
                        c.JSON(http.StatusNotFound, gin.H{"error": "user not found"})
                        return
                }</span>
                <span class="cov0" title="0">c.JSON(http.StatusInternalServerError, gin.H{"error": "failed to get user"})
                return</span>
        }

        <span class="cov0" title="0">c.JSON(http.StatusOK, UserProfileResponse{
                ID:          user.ID,
                DisplayID:   user.DisplayID,
                DisplayName: user.DisplayName,
                AvatarURL:   user.AvatarURL,
                Bio:         user.Bio,
        })</span>
}

// ユーザーが作成したタグ一覧を取得する。
// GET /api/v1/users/:displayId/tags
func (h *UserHandler) ListUserTags(c *gin.Context) <span class="cov0" title="0">{
        displayID := c.Param("displayId")
        if displayID == "" </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, gin.H{"error": "display_id is required"})
                return
        }</span>

        // display_id からユーザーを取得
        <span class="cov0" title="0">user, err := h.userService.GetUserByDisplayID(c.Request.Context(), displayID)
        if err != nil </span><span class="cov0" title="0">{
                if errors.Is(err, service.ErrUserNotFound) </span><span class="cov0" title="0">{
                        c.JSON(http.StatusNotFound, gin.H{"error": "user not found"})
                        return
                }</span>
                <span class="cov0" title="0">c.JSON(http.StatusInternalServerError, gin.H{"error": "failed to get user"})
                return</span>
        }

        <span class="cov0" title="0">page := parseIntDefaultUser(c.Query("page"), 1)
        pageSize := parseIntDefaultUser(c.Query("page_size"), 20)

        // 閲覧者が本人かどうかを判定
        publicOnly := true
        if viewerRaw, exists := c.Get("user"); exists </span><span class="cov0" title="0">{
                if viewer, ok := viewerRaw.(*model.User); ok &amp;&amp; viewer != nil &amp;&amp; viewer.ID == user.ID </span><span class="cov0" title="0">{
                        publicOnly = false // 本人なら非公開タグも表示
                }</span>
        }

        <span class="cov0" title="0">items, total, err := h.tagService.ListTagsByUserID(c.Request.Context(), user.ID, publicOnly, page, pageSize)
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusInternalServerError, gin.H{"error": "failed to list user tags"})
                return
        }</span>

        <span class="cov0" title="0">c.JSON(http.StatusOK, gin.H{
                "items":       items,
                "page":        page,
                "page_size":   pageSize,
                "total_count": total,
        })</span>
}

// FollowUser は指定ユーザーをフォローします。
// POST /api/v1/users/:displayId/follow
func (h *UserHandler) FollowUser(c *gin.Context) <span class="cov0" title="0">{
        displayID := c.Param("displayId")
        requestID := middleware.GetRequestID(c)

        // 開始ログ（INFO）
        attrs := []any{
                slog.String("request_id", requestID),
                slog.String("display_id", displayID),
        }

        // 認証済みの場合は user_id も含める
        if userVal, ok := c.Get("user"); ok </span><span class="cov0" title="0">{
                if user, ok2 := userVal.(*model.User); ok2 &amp;&amp; user != nil </span><span class="cov0" title="0">{
                        attrs = append(attrs, slog.String("user_id", user.ID))
                }</span>
        }

        <span class="cov0" title="0">h.logger.Info("handler.FollowUser started", attrs...)
        if displayID == "" </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, gin.H{"error": "display_id is required"})
                return
        }</span>

        // 認証ユーザーを取得
        <span class="cov0" title="0">userRaw, exists := c.Get("user")
        if !exists </span><span class="cov0" title="0">{
                c.JSON(http.StatusUnauthorized, gin.H{"error": "unauthorized"})
                return
        }</span>

        <span class="cov0" title="0">currentUser, ok := userRaw.(*model.User)
        if !ok || currentUser == nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusInternalServerError, gin.H{"error": "invalid user context"})
                return
        }</span>

        // フォロー対象のユーザーを取得
        <span class="cov0" title="0">targetUser, err := h.userService.GetUserByDisplayID(c.Request.Context(), displayID)
        if err != nil </span><span class="cov0" title="0">{
                if errors.Is(err, service.ErrUserNotFound) </span><span class="cov0" title="0">{
                        c.JSON(http.StatusNotFound, gin.H{"error": "user not found"})
                        return
                }</span>
                <span class="cov0" title="0">c.JSON(http.StatusInternalServerError, gin.H{"error": "failed to get user"})
                return</span>
        }

        // フォローを実行
        <span class="cov0" title="0">err = h.userService.FollowUser(c.Request.Context(), currentUser.ID, targetUser.ID)
        if err != nil </span><span class="cov0" title="0">{
                if errors.Is(err, service.ErrUserNotFound) </span><span class="cov0" title="0">{
                        c.JSON(http.StatusNotFound, gin.H{"error": "user not found"})
                        return
                }</span>
                <span class="cov0" title="0">if errors.Is(err, service.ErrCannotFollowSelf) </span><span class="cov0" title="0">{
                        c.JSON(http.StatusBadRequest, gin.H{"error": "cannot follow yourself"})
                        return
                }</span>
                <span class="cov0" title="0">if errors.Is(err, service.ErrAlreadyFollowing) </span><span class="cov0" title="0">{
                        c.JSON(http.StatusConflict, gin.H{"error": "already following"})
                        return
                }</span>
                <span class="cov0" title="0">c.JSON(http.StatusInternalServerError, gin.H{"error": "failed to follow user"})
                return</span>
        }

        <span class="cov0" title="0">c.JSON(http.StatusOK, gin.H{"message": "successfully followed"})</span>
}

// 指定ユーザーをアンフォローする。
// DELETE /api/v1/users/:displayId/follow
func (h *UserHandler) UnfollowUser(c *gin.Context) <span class="cov0" title="0">{
        displayID := c.Param("displayId")
        if displayID == "" </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, gin.H{"error": "display_id is required"})
                return
        }</span>

        // 認証ユーザーを取得
        <span class="cov0" title="0">userRaw, exists := c.Get("user")
        if !exists </span><span class="cov0" title="0">{
                c.JSON(http.StatusUnauthorized, gin.H{"error": "unauthorized"})
                return
        }</span>

        <span class="cov0" title="0">currentUser, ok := userRaw.(*model.User)
        if !ok || currentUser == nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusInternalServerError, gin.H{"error": "invalid user context"})
                return
        }</span>

        // アンフォロー対象のユーザーを取得
        <span class="cov0" title="0">targetUser, err := h.userService.GetUserByDisplayID(c.Request.Context(), displayID)
        if err != nil </span><span class="cov0" title="0">{
                if errors.Is(err, service.ErrUserNotFound) </span><span class="cov0" title="0">{
                        c.JSON(http.StatusNotFound, gin.H{"error": "user not found"})
                        return
                }</span>
                <span class="cov0" title="0">c.JSON(http.StatusInternalServerError, gin.H{"error": "failed to get user"})
                return</span>
        }

        // アンフォローを実行
        <span class="cov0" title="0">err = h.userService.UnfollowUser(c.Request.Context(), currentUser.ID, targetUser.ID)
        if err != nil </span><span class="cov0" title="0">{
                if errors.Is(err, service.ErrNotFollowing) </span><span class="cov0" title="0">{
                        c.JSON(http.StatusConflict, gin.H{"error": "not following"})
                        return
                }</span>
                <span class="cov0" title="0">c.JSON(http.StatusInternalServerError, gin.H{"error": "failed to unfollow user"})
                return</span>
        }

        <span class="cov0" title="0">c.JSON(http.StatusOK, gin.H{"message": "successfully unfollowed"})</span>
}

// 指定ユーザーがフォローしているユーザー一覧を取得する。
// GET /api/v1/users/:displayId/following
func (h *UserHandler) ListFollowing(c *gin.Context) <span class="cov0" title="0">{
        displayID := c.Param("displayId")
        if displayID == "" </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, gin.H{"error": "display_id is required"})
                return
        }</span>

        // ユーザーを取得
        <span class="cov0" title="0">user, err := h.userService.GetUserByDisplayID(c.Request.Context(), displayID)
        if err != nil </span><span class="cov0" title="0">{
                if errors.Is(err, service.ErrUserNotFound) </span><span class="cov0" title="0">{
                        c.JSON(http.StatusNotFound, gin.H{"error": "user not found"})
                        return
                }</span>
                <span class="cov0" title="0">c.JSON(http.StatusInternalServerError, gin.H{"error": "failed to get user"})
                return</span>
        }

        <span class="cov0" title="0">page := parseIntDefaultUser(c.Query("page"), 1)
        pageSize := parseIntDefaultUser(c.Query("page_size"), 20)

        users, total, err := h.userService.ListFollowing(c.Request.Context(), user.ID, page, pageSize)
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusInternalServerError, gin.H{"error": "failed to list following"})
                return
        }</span>

        <span class="cov0" title="0">items := make([]UserProfileResponse, len(users))
        for i, u := range users </span><span class="cov0" title="0">{
                items[i] = UserProfileResponse{
                        ID:          u.ID,
                        DisplayID:   u.DisplayID,
                        DisplayName: u.DisplayName,
                        AvatarURL:   u.AvatarURL,
                        Bio:         u.Bio,
                }
        }</span>

        <span class="cov0" title="0">c.JSON(http.StatusOK, gin.H{
                "items":       items,
                "page":        page,
                "page_size":   pageSize,
                "total_count": total,
        })</span>
}

// 指定ユーザーをフォローしているユーザー一覧を取得する。
// GET /api/v1/users/:displayId/followers
func (h *UserHandler) ListFollowers(c *gin.Context) <span class="cov0" title="0">{
        displayID := c.Param("displayId")
        if displayID == "" </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, gin.H{"error": "display_id is required"})
                return
        }</span>

        // ユーザーを取得
        <span class="cov0" title="0">user, err := h.userService.GetUserByDisplayID(c.Request.Context(), displayID)
        if err != nil </span><span class="cov0" title="0">{
                if errors.Is(err, service.ErrUserNotFound) </span><span class="cov0" title="0">{
                        c.JSON(http.StatusNotFound, gin.H{"error": "user not found"})
                        return
                }</span>
                <span class="cov0" title="0">c.JSON(http.StatusInternalServerError, gin.H{"error": "failed to get user"})
                return</span>
        }

        <span class="cov0" title="0">page := parseIntDefaultUser(c.Query("page"), 1)
        pageSize := parseIntDefaultUser(c.Query("page_size"), 20)

        users, total, err := h.userService.ListFollowers(c.Request.Context(), user.ID, page, pageSize)
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusInternalServerError, gin.H{"error": "failed to list followers"})
                return
        }</span>

        <span class="cov0" title="0">items := make([]UserProfileResponse, len(users))
        for i, u := range users </span><span class="cov0" title="0">{
                items[i] = UserProfileResponse{
                        ID:          u.ID,
                        DisplayID:   u.DisplayID,
                        DisplayName: u.DisplayName,
                        AvatarURL:   u.AvatarURL,
                        Bio:         u.Bio,
                }
        }</span>

        <span class="cov0" title="0">c.JSON(http.StatusOK, gin.H{
                "items":       items,
                "page":        page,
                "page_size":   pageSize,
                "total_count": total,
        })</span>
}

// ユーザーのフォロー数・フォロワー数を取得する。
// GET /api/v1/users/:displayId/follow-stats
func (h *UserHandler) GetUserFollowStats(c *gin.Context) <span class="cov0" title="0">{
        displayID := c.Param("displayId")
        if displayID == "" </span><span class="cov0" title="0">{
                c.JSON(http.StatusBadRequest, gin.H{"error": "display_id is required"})
                return
        }</span>

        // ユーザーを取得
        <span class="cov0" title="0">user, err := h.userService.GetUserByDisplayID(c.Request.Context(), displayID)
        if err != nil </span><span class="cov0" title="0">{
                if errors.Is(err, service.ErrUserNotFound) </span><span class="cov0" title="0">{
                        c.JSON(http.StatusNotFound, gin.H{"error": "user not found"})
                        return
                }</span>
                <span class="cov0" title="0">c.JSON(http.StatusInternalServerError, gin.H{"error": "failed to get user"})
                return</span>
        }

        <span class="cov0" title="0">following, followers, err := h.userService.GetFollowStats(c.Request.Context(), user.ID)
        if err != nil </span><span class="cov0" title="0">{
                c.JSON(http.StatusInternalServerError, gin.H{"error": "failed to get follow stats"})
                return
        }</span>

        // 認証ユーザーがこのユーザーをフォローしているか確認
        <span class="cov0" title="0">isFollowing := false
        if viewerRaw, exists := c.Get("user"); exists </span><span class="cov0" title="0">{
                if viewer, ok := viewerRaw.(*model.User); ok &amp;&amp; viewer != nil </span><span class="cov0" title="0">{
                        isFollowing, _ = h.userService.IsFollowing(c.Request.Context(), viewer.ID, user.ID)
                }</span>
        }

        <span class="cov0" title="0">c.JSON(http.StatusOK, gin.H{
                "following_count": following,
                "followers_count": followers,
                "is_following":    isFollowing,
        })</span>
}

// ユーザーのページ番号とページサイズを取得する。
func parseIntDefaultUser(s string, def int) int <span class="cov0" title="0">{
        // ページ番号が空の場合はデフォルト値を返す
        if s == "" </span><span class="cov0" title="0">{
                return def
        }</span>

        // ページ番号を整数に変換。変換に失敗した場合はデフォルト値を返す。
        <span class="cov0" title="0">v, err := strconv.Atoi(s)
        if err != nil </span><span class="cov0" title="0">{
                return def
        }</span>

        <span class="cov0" title="0">return v</span>
}
</pre>
		
		<pre class="file" id="file8" style="display: none">package logger

import (
        "log/slog"
        "os"
        "strings"
)

// 環境変数に基づいて設定された *slog.Logger を返す。
//
// 環境変数:
//   - LOG_LEVEL: debug / info / warn / error (デフォルト: info)
//   - GIN_MODE: release (JSON形式) / development (テキスト形式)
func NewLogger() *slog.Logger <span class="cov0" title="0">{
        level := parseLogLevel(os.Getenv("LOG_LEVEL"))
        isProduction := os.Getenv("GIN_MODE") == "release"

        opts := &amp;slog.HandlerOptions{
                Level: level,
        }

        var handler slog.Handler
        if isProduction </span><span class="cov0" title="0">{
                // 本番環境: JSON形式
                handler = slog.NewJSONHandler(os.Stdout, opts)
        }</span> else<span class="cov0" title="0"> {
                // 開発環境: テキスト形式
                handler = slog.NewTextHandler(os.Stdout, opts)
        }</span>

        <span class="cov0" title="0">return slog.New(handler)</span>
}

// 文字列からログレベルを解析する。
// 不明な値の場合は slog.LevelInfo を返す。
func parseLogLevel(s string) slog.Level <span class="cov0" title="0">{
        switch strings.ToLower(s) </span>{
        case "debug":<span class="cov0" title="0">
                return slog.LevelDebug</span>
        case "info":<span class="cov0" title="0">
                return slog.LevelInfo</span>
        case "warn", "warning":<span class="cov0" title="0">
                return slog.LevelWarn</span>
        case "error":<span class="cov0" title="0">
                return slog.LevelError</span>
        default:<span class="cov0" title="0">
                return slog.LevelInfo</span>
        }
}
</pre>
		
		<pre class="file" id="file9" style="display: none">package middleware

import (
        "log/slog"
        "net/http"
        "os"
        "strings"

        "cinetag-backend/src/internal/service"

        "github.com/gin-gonic/gin"
)

// NewAuthMiddleware は、Clerk トークンの検証（暫定）と
// users テーブルとの同期を行う認証ミドルウェアを返します。
//
// NOTE:
//   - Clerk の JWKS で RS256 JWT を検証し、sub（Clerk user ID）を信頼できる形で取得します。
//   - JWKS の取得先は環境変数 `CLERK_JWKS_URL` に設定してください。
//   - 必要なら `CLERK_ISSUER` / `CLERK_AUDIENCE` も指定し、iss/aud の検証を有効化できます。
func NewAuthMiddleware(logger *slog.Logger, userService service.UserService) gin.HandlerFunc <span class="cov8" title="1">{
        // 初期化ログ（DEBUG）
        logger.Debug("middleware.NewAuthMiddleware initialized")

        jwksURL := os.Getenv("CLERK_JWKS_URL")
        issuer := os.Getenv("CLERK_ISSUER")
        audience := os.Getenv("CLERK_AUDIENCE")

        // Clerk JWT 検証器を生成する。
        validator, err := NewClerkJWTValidator(jwksURL, issuer, audience)
        if err != nil </span><span class="cov8" title="1">{
                // ルーティング初期化時に気づけるようログに出し、リクエストは 500 を返す
                logger.Error("AuthMiddleware misconfigured", slog.Any("error", err))
                validator = nil
        }</span>

        <span class="cov8" title="1">return func(c *gin.Context) </span><span class="cov8" title="1">{

                // Clerk JWT 検証器が生成できなかった場合は 500 を返す。
                if validator == nil </span><span class="cov8" title="1">{
                        c.JSON(http.StatusInternalServerError, gin.H{
                                "error": "auth middleware misconfigured",
                        })
                        c.Abort()
                        return
                }</span>

                // Authorization ヘッダーを取得する。
                <span class="cov8" title="1">authHeader := c.GetHeader("Authorization")
                // Authorization ヘッダーが空か Bearer 形式でない場合は 401 を返す。
                if authHeader == "" || !strings.HasPrefix(authHeader, "Bearer ") </span><span class="cov8" title="1">{
                        c.JSON(http.StatusUnauthorized, gin.H{
                                "error": "unauthorized",
                        })
                        c.Abort()
                        return
                }</span>

                // Bearer トークンを取得する。
                <span class="cov8" title="1">rawToken := strings.TrimSpace(strings.TrimPrefix(authHeader, "Bearer "))
                if rawToken == "" </span><span class="cov0" title="0">{
                        c.JSON(http.StatusUnauthorized, gin.H{
                                "error": "unauthorized",
                        })
                        c.Abort()
                        return
                }</span>

                // Bearer トークンを検証する。
                <span class="cov8" title="1">claims, err := validator.Verify(c.Request.Context(), rawToken)
                if err != nil </span><span class="cov8" title="1">{
                        c.JSON(http.StatusUnauthorized, gin.H{
                                "error": "unauthorized",
                        })
                        c.Abort()
                        return
                }</span>

                // ClerkUserInfo を作成する。
                <span class="cov8" title="1">clerkUser, err := service.NewClerkUserInfoFromJWTClaims(claims)
                if err != nil </span><span class="cov8" title="1">{
                        c.JSON(http.StatusUnauthorized, gin.H{
                                "error": "unauthorized",
                        })
                        c.Abort()
                        return
                }</span>

                // users テーブルと同期する。
                <span class="cov8" title="1">user, err := userService.EnsureUser(c.Request.Context(), clerkUser)
                if err != nil </span><span class="cov8" title="1">{
                        c.JSON(http.StatusInternalServerError, gin.H{
                                "error": "failed to ensure user",
                        })
                        c.Abort()
                        return
                }</span>

                // 後続のハンドラーから参照できるよう、コンテキストに格納。
                <span class="cov8" title="1">c.Set("user", user)

                // 次のハンドラーに処理を渡す。
                c.Next()</span>
        }
}
</pre>
		
		<pre class="file" id="file10" style="display: none">package middleware

import (
        "context"
        "crypto"
        "crypto/rsa"
        "crypto/sha256"
        "encoding/base64"
        "encoding/json"
        "errors"
        "fmt"
        "math/big"
        "net/http"
        "strings"
        "sync"
        "time"
)

// Clerk が発行する JWT を JWKS を使って検証するためのヘルパー。
// 外部依存（JWTライブラリ）を追加せず、RS256 のみを最小実装でサポートする。
type ClerkJWTValidator struct {
        jwksURL  string
        issuer   string
        audience string

        client *http.Client
        cache  *jwksCache
}

// Clerk JWT 検証器を生成する。
// - jwksURL は必須。
// - issuer/audience は空の場合は検証しない。
func NewClerkJWTValidator(jwksURL, issuer, audience string) (*ClerkJWTValidator, error) <span class="cov8" title="1">{
        jwksURL = strings.TrimSpace(jwksURL)
        if jwksURL == "" </span><span class="cov8" title="1">{
                return nil, errors.New("CLERK_JWKS_URL is required")
        }</span>

        // Clerk JWT 検証器を生成。
        <span class="cov8" title="1">v := &amp;ClerkJWTValidator{
                jwksURL:  jwksURL,
                issuer:   strings.TrimSpace(issuer),
                audience: strings.TrimSpace(audience),
                client:   &amp;http.Client{Timeout: 5 * time.Second},
        }
        v.cache = newJWKSCache(v.client, jwksURL, 15*time.Minute)
        return v, nil</span>
}

// JWT ヘッダーの構造。
type jwtHeader struct {
        Alg string `json:"alg"`
        Kid string `json:"kid"`
        Typ string `json:"typ"`
}

// JWT の署名/期限/（任意でiss/aud）を検証し、payload(claims)を返す。
func (v *ClerkJWTValidator) Verify(ctx context.Context, token string) (map[string]any, error) <span class="cov8" title="1">{
        token = strings.TrimSpace(token)
        if token == "" </span><span class="cov0" title="0">{
                return nil, errors.New("empty token")
        }</span>

        // JWT をパース。
        <span class="cov8" title="1">parts := strings.Split(token, ".")
        if len(parts) != 3 </span><span class="cov8" title="1">{
                return nil, errors.New("invalid token format")
        }</span>

        // JWT ヘッダーをデコード。
        <span class="cov8" title="1">headerJSON, err := base64.RawURLEncoding.DecodeString(parts[0])
        if err != nil </span><span class="cov0" title="0">{
                return nil, errors.New("invalid token header encoding")
        }</span>

        // JWT ヘッダーをパース。
        <span class="cov8" title="1">var h jwtHeader
        if err := json.Unmarshal(headerJSON, &amp;h); err != nil </span><span class="cov0" title="0">{
                return nil, errors.New("invalid token header json")
        }</span>

        // JWT アルゴリズムが RS256 でない場合はエラー。
        <span class="cov8" title="1">if h.Alg != "RS256" </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("unsupported jwt alg: %s", h.Alg)
        }</span>

        // JWT ヘッダーに kid がない場合はエラー。
        <span class="cov8" title="1">if strings.TrimSpace(h.Kid) == "" </span><span class="cov8" title="1">{
                return nil, errors.New("missing kid in jwt header")
        }</span>

        // JWT ペイロードをデコード。
        <span class="cov8" title="1">payloadJSON, err := base64.RawURLEncoding.DecodeString(parts[1])
        if err != nil </span><span class="cov0" title="0">{
                return nil, errors.New("invalid token payload encoding")
        }</span>

        // JWT ペイロードをパース。
        <span class="cov8" title="1">claims := map[string]any{}
        if err := json.Unmarshal(payloadJSON, &amp;claims); err != nil </span><span class="cov0" title="0">{
                return nil, errors.New("invalid token payload json")
        }</span>

        // exp/nbf の検証（存在する場合）
        <span class="cov8" title="1">now := time.Now().Unix()
        if exp, ok := getNumericClaim(claims, "exp"); ok </span><span class="cov8" title="1">{
                if now &gt;= exp </span><span class="cov8" title="1">{
                        return nil, errors.New("token expired")
                }</span>
        }
        <span class="cov8" title="1">if nbf, ok := getNumericClaim(claims, "nbf"); ok </span><span class="cov8" title="1">{
                if now &lt; nbf </span><span class="cov8" title="1">{
                        return nil, errors.New("token not yet valid")
                }</span>
        }

        // iss/aud の検証（設定されている場合のみ）
        <span class="cov8" title="1">if v.issuer != "" </span><span class="cov8" title="1">{
                if iss, _ := claims["iss"].(string); iss != v.issuer </span><span class="cov8" title="1">{
                        return nil, errors.New("invalid issuer")
                }</span>
        }
        <span class="cov8" title="1">if v.audience != "" </span><span class="cov8" title="1">{
                if !audMatches(claims["aud"], v.audience) </span><span class="cov8" title="1">{
                        return nil, errors.New("invalid audience")
                }</span>
        }

        // JWT 署名をデコード。
        <span class="cov8" title="1">sig, err := base64.RawURLEncoding.DecodeString(parts[2])
        if err != nil </span><span class="cov0" title="0">{
                return nil, errors.New("invalid token signature encoding")
        }</span>

        // JWT 署名を検証。
        <span class="cov8" title="1">signingInput := parts[0] + "." + parts[1]
        sum := sha256.Sum256([]byte(signingInput))

        // JWK を取得。
        pubAny, err := v.cache.getKey(ctx, h.Kid)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get jwk: %w", err)
        }</span>

        // JWK をパース。
        <span class="cov8" title="1">pub, ok := pubAny.(*rsa.PublicKey)
        if !ok || pub == nil </span><span class="cov0" title="0">{
                return nil, errors.New("invalid jwk type")
        }</span>

        // JWT 署名を検証。
        <span class="cov8" title="1">if err := rsa.VerifyPKCS1v15(pub, crypto.SHA256, sum[:], sig); err != nil </span><span class="cov8" title="1">{
                return nil, errors.New("invalid token signature")
        }</span>

        <span class="cov8" title="1">return claims, nil</span>
}

// JWT ペイロードの数値型のクレームを取得する。
func getNumericClaim(claims map[string]any, key string) (int64, bool) <span class="cov8" title="1">{
        v, ok := claims[key]
        if !ok || v == nil </span><span class="cov8" title="1">{
                return 0, false
        }</span>
        <span class="cov8" title="1">switch t := v.(type) </span>{
        case float64:<span class="cov8" title="1">
                return int64(t), true</span>
        case json.Number:<span class="cov0" title="0">
                n, err := t.Int64()
                if err != nil </span><span class="cov0" title="0">{
                        return 0, false
                }</span>
                <span class="cov0" title="0">return n, true</span>
        case int64:<span class="cov0" title="0">
                return t, true</span>
        case int:<span class="cov0" title="0">
                return int64(t), true</span>
        default:<span class="cov0" title="0">
                return 0, false</span>
        }
}

// JWT ペイロードの aud が expected と一致するか確認する。
func audMatches(aud any, expected string) bool <span class="cov8" title="1">{
        switch t := aud.(type) </span>{
        case string:<span class="cov8" title="1">
                return t == expected</span>
        case []any:<span class="cov0" title="0">
                for _, v := range t </span><span class="cov0" title="0">{
                        if s, ok := v.(string); ok &amp;&amp; s == expected </span><span class="cov0" title="0">{
                                return true
                        }</span>
                }
                <span class="cov0" title="0">return false</span>
        case []string:<span class="cov0" title="0">
                for _, s := range t </span><span class="cov0" title="0">{
                        if s == expected </span><span class="cov0" title="0">{
                                return true
                        }</span>
                }
                <span class="cov0" title="0">return false</span>
        default:<span class="cov0" title="0">
                return false</span>
        }
}

// JWKS キャッシュの構造。
type jwksCache struct {
        client *http.Client
        url    string
        ttl    time.Duration

        mu        sync.RWMutex
        fetchedAt time.Time
        keys      map[string]*rsa.PublicKey
}

// JWKS キャッシュを生成する。
func newJWKSCache(client *http.Client, url string, ttl time.Duration) *jwksCache <span class="cov8" title="1">{
        return &amp;jwksCache{
                client: client,
                url:    url,
                ttl:    ttl,
                keys:   map[string]*rsa.PublicKey{},
        }
}</span>

// JWKS レスポンスの構造。
type jwksResponse struct {
        Keys []jwk `json:"keys"`
}

// JWK の構造。
type jwk struct {
        Kty string `json:"kty"`
        Kid string `json:"kid"`
        Use string `json:"use"`
        Alg string `json:"alg"`
        N   string `json:"n"`
        E   string `json:"e"`
}

// JWK を取得する。
func (c *jwksCache) getKey(ctx context.Context, kid string) (any, error) <span class="cov8" title="1">{
        // まずキャッシュヒットを狙う
        c.mu.RLock()
        key, ok := c.keys[kid]
        fetchedAt := c.fetchedAt
        c.mu.RUnlock()

        if ok &amp;&amp; key != nil &amp;&amp; time.Since(fetchedAt) &lt; c.ttl </span><span class="cov0" title="0">{
                return key, nil
        }</span>

        // miss or stale なら refresh
        <span class="cov8" title="1">if err := c.refresh(ctx); err != nil </span><span class="cov0" title="0">{
                // refresh が失敗しても、古いキャッシュに目的のkidがあれば使う（ベストエフォート）
                c.mu.RLock()
                key2, ok2 := c.keys[kid]
                c.mu.RUnlock()
                if ok2 &amp;&amp; key2 != nil </span><span class="cov0" title="0">{
                        return key2, nil
                }</span>
                <span class="cov0" title="0">return nil, err</span>
        }

        <span class="cov8" title="1">c.mu.RLock()
        key, ok = c.keys[kid]
        c.mu.RUnlock()
        if !ok || key == nil </span><span class="cov0" title="0">{
                return nil, errors.New("kid not found in jwks")
        }</span>
        <span class="cov8" title="1">return key, nil</span>
}

// JWKS をリフレッシュする。
func (c *jwksCache) refresh(ctx context.Context) error <span class="cov8" title="1">{
        req, err := http.NewRequestWithContext(ctx, http.MethodGet, c.url, nil)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">resp, err := c.client.Do(req)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">defer resp.Body.Close()

        if resp.StatusCode &lt; 200 || resp.StatusCode &gt;= 300 </span><span class="cov0" title="0">{
                return fmt.Errorf("jwks fetch failed: status=%d", resp.StatusCode)
        }</span>

        <span class="cov8" title="1">var jwks jwksResponse
        if err := json.NewDecoder(resp.Body).Decode(&amp;jwks); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">next := map[string]*rsa.PublicKey{}
        for _, k := range jwks.Keys </span><span class="cov8" title="1">{
                if k.Kty != "RSA" || strings.TrimSpace(k.Kid) == "" || k.N == "" || k.E == "" </span><span class="cov0" title="0">{
                        continue</span>
                }
                <span class="cov8" title="1">pub, err := rsaPublicKeyFromJWK(k.N, k.E)
                if err != nil </span><span class="cov0" title="0">{
                        continue</span>
                }
                <span class="cov8" title="1">next[k.Kid] = pub</span>
        }

        <span class="cov8" title="1">if len(next) == 0 </span><span class="cov0" title="0">{
                return errors.New("jwks contains no usable keys")
        }</span>

        <span class="cov8" title="1">c.mu.Lock()
        c.keys = next
        c.fetchedAt = time.Now()
        c.mu.Unlock()

        return nil</span>
}

// JWK を RSA 公開鍵に変換する。
func rsaPublicKeyFromJWK(nB64, eB64 string) (*rsa.PublicKey, error) <span class="cov8" title="1">{
        nBytes, err := base64.RawURLEncoding.DecodeString(nB64)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">eBytes, err := base64.RawURLEncoding.DecodeString(eB64)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">if len(eBytes) == 0 </span><span class="cov0" title="0">{
                return nil, errors.New("empty exponent")
        }</span>

        <span class="cov8" title="1">n := new(big.Int).SetBytes(nBytes)
        e := 0
        for _, b := range eBytes </span><span class="cov8" title="1">{
                e = e&lt;&lt;8 + int(b)
        }</span>
        <span class="cov8" title="1">if e == 0 </span><span class="cov0" title="0">{
                return nil, errors.New("invalid exponent")
        }</span>

        <span class="cov8" title="1">return &amp;rsa.PublicKey{N: n, E: e}, nil</span>
}
</pre>
		
		<pre class="file" id="file11" style="display: none">package middleware

import (
        "log/slog"
        "net/http"
        "os"
        "strings"

        "cinetag-backend/src/internal/service"

        "github.com/gin-gonic/gin"
)

// Authorization ヘッダーが付いている場合のみ Clerk JWT を検証し、
// users テーブルと同期した User をコンテキストに設定する。
// - Authorization が無い場合: そのまま通す（匿名アクセス）
// - Authorization があるが不正: 401 を返す
// - CLERK_JWKS_URL 等の検証器の設定は AuthMiddleware と同様。
func NewOptionalAuthMiddleware(logger *slog.Logger, userService service.UserService) gin.HandlerFunc <span class="cov0" title="0">{
        // 初期化ログ（DEBUG）
        logger.Debug("middleware.NewOptionalAuthMiddleware initialized")

        jwksURL := os.Getenv("CLERK_JWKS_URL")
        issuer := os.Getenv("CLERK_ISSUER")
        audience := os.Getenv("CLERK_AUDIENCE")

        // Clerk JWT 検証器を生成する。
        validator, err := NewClerkJWTValidator(jwksURL, issuer, audience)
        if err != nil </span><span class="cov0" title="0">{
                logger.Error("OptionalAuthMiddleware misconfigured", slog.Any("error", err))
                validator = nil
        }</span>

        <span class="cov0" title="0">return func(c *gin.Context) </span><span class="cov0" title="0">{

                // Clerk JWT 検証器が生成できなかった場合は 500 を返す。
                if validator == nil </span><span class="cov0" title="0">{
                        c.JSON(http.StatusInternalServerError, gin.H{
                                "error": "auth middleware misconfigured",
                        })
                        c.Abort()
                        return
                }</span>

                // Authorization ヘッダーを取得する。
                <span class="cov0" title="0">authHeader := strings.TrimSpace(c.GetHeader("Authorization"))
                if authHeader == "" </span><span class="cov0" title="0">{
                        // Authorization ヘッダーが空の場合はそのまま通す。
                        c.Next()
                        return
                }</span>
                <span class="cov0" title="0">if !strings.HasPrefix(authHeader, "Bearer ") </span><span class="cov0" title="0">{
                        // Authorization ヘッダーが Bearer 形式でない場合は 401 を返す。
                        c.JSON(http.StatusUnauthorized, gin.H{"error": "unauthorized"})
                        c.Abort()
                        return
                }</span>

                // Bearer トークンを取得する
                <span class="cov0" title="0">rawToken := strings.TrimSpace(strings.TrimPrefix(authHeader, "Bearer "))
                if rawToken == "" </span><span class="cov0" title="0">{
                        c.JSON(http.StatusUnauthorized, gin.H{"error": "unauthorized"})
                        c.Abort()
                        return
                }</span>

                // トークンを検証する
                <span class="cov0" title="0">claims, err := validator.Verify(c.Request.Context(), rawToken)
                if err != nil </span><span class="cov0" title="0">{
                        c.JSON(http.StatusUnauthorized, gin.H{"error": "unauthorized"})
                        c.Abort()
                        return
                }</span>

                // ClerkUserInfo を作成する
                <span class="cov0" title="0">clerkUser, err := service.NewClerkUserInfoFromJWTClaims(claims)
                if err != nil </span><span class="cov0" title="0">{
                        c.JSON(http.StatusUnauthorized, gin.H{"error": "unauthorized"})
                        c.Abort()
                        return
                }</span>

                <span class="cov0" title="0">user, err := userService.EnsureUser(c.Request.Context(), clerkUser)
                if err != nil </span><span class="cov0" title="0">{
                        c.JSON(http.StatusInternalServerError, gin.H{"error": "failed to ensure user"})
                        c.Abort()
                        return
                }</span>

                <span class="cov0" title="0">c.Set("user", user)
                c.Next()</span>
        }
}
</pre>
		
		<pre class="file" id="file12" style="display: none">package middleware

import (
        "log/slog"
        "net/http"
        "runtime/debug"

        "github.com/gin-gonic/gin"
)

// NewRecoveryMiddleware はパニックをリカバリーしてログ出力するミドルウェアを返します。
//
// gin.Recovery() の代替として使用し、パニック発生時に以下の情報をログ出力します:
//   - request_id: リクエストID（設定されている場合）
//   - method: HTTPメソッド
//   - path: リクエストパス
//   - error: パニックの内容
//   - stack: スタックトレース
func NewRecoveryMiddleware(logger *slog.Logger) gin.HandlerFunc <span class="cov0" title="0">{
        return func(c *gin.Context) </span><span class="cov0" title="0">{
                defer func() </span><span class="cov0" title="0">{
                        if err := recover(); err != nil </span><span class="cov0" title="0">{
                                // スタックトレースを取得
                                stack := string(debug.Stack())

                                // リクエストIDを取得（設定されている場合）
                                requestID := GetRequestID(c)

                                // エラーログを出力
                                logger.Error("panic recovered",
                                        slog.String("request_id", requestID),
                                        slog.String("method", c.Request.Method),
                                        slog.String("path", c.Request.URL.Path),
                                        slog.Any("error", err),
                                        slog.String("stack", stack),
                                )

                                // 500 Internal Server Error を返す
                                c.AbortWithStatusJSON(http.StatusInternalServerError, gin.H{
                                        "error": "internal server error",
                                })
                        }</span>
                }()

                <span class="cov0" title="0">c.Next()</span>
        }
}
</pre>
		
		<pre class="file" id="file13" style="display: none">package middleware

import (
        "log/slog"
        "time"

        "github.com/gin-gonic/gin"
        "github.com/google/uuid"
)

// ContextKeyRequestID はコンテキストに格納するリクエストIDのキー。
const ContextKeyRequestID = "request_id"

// NewRequestLoggerMiddleware はリクエストログを出力するミドルウェアを返す。
//
// 各リクエストに UUID を付与し、リクエスト完了時に以下の情報をログ出力する:
//   - request_id: リクエストを識別するUUID
//   - method: HTTPメソッド
//   - path: リクエストパス
//   - status: HTTPステータスコード
//   - latency: 処理時間
//   - client_ip: クライアントIP
func NewRequestLoggerMiddleware(logger *slog.Logger) gin.HandlerFunc <span class="cov0" title="0">{
        return func(c *gin.Context) </span><span class="cov0" title="0">{
                // リクエストIDを生成してコンテキストに設定
                requestID := uuid.NewString()
                c.Set(ContextKeyRequestID, requestID)

                // リクエスト開始時刻を記録
                start := time.Now()
                path := c.Request.URL.Path
                query := c.Request.URL.RawQuery

                // 次のハンドラーを実行
                c.Next()

                // リクエスト完了後のログ出力
                latency := time.Since(start)
                status := c.Writer.Status()

                // クエリパラメータがある場合はパスに付与
                if query != "" </span><span class="cov0" title="0">{
                        path = path + "?" + query
                }</span>

                // ログ属性を構築
                <span class="cov0" title="0">attrs := []any{
                        slog.String("request_id", requestID),
                        slog.String("method", c.Request.Method),
                        slog.String("path", path),
                        slog.Int("status", status),
                        slog.Duration("latency", latency),
                        slog.String("client_ip", c.ClientIP()),
                }

                // エラーがある場合は追加
                if len(c.Errors) &gt; 0 </span><span class="cov0" title="0">{
                        attrs = append(attrs, slog.String("errors", c.Errors.String()))
                }</span>

                // ステータスコードに応じてログレベルを変更
                <span class="cov0" title="0">switch </span>{
                case status &gt;= 500:<span class="cov0" title="0">
                        logger.Error("request", attrs...)</span>
                case status &gt;= 400:<span class="cov0" title="0">
                        logger.Warn("request", attrs...)</span>
                default:<span class="cov0" title="0">
                        logger.Info("request", attrs...)</span>
                }
        }
}

// GetRequestID はコンテキストからリクエストIDを取得します。
// リクエストIDが見つからない場合は空文字列を返します。
func GetRequestID(c *gin.Context) string <span class="cov0" title="0">{
        if id, ok := c.Get(ContextKeyRequestID); ok </span><span class="cov0" title="0">{
                if requestID, ok := id.(string); ok </span><span class="cov0" title="0">{
                        return requestID
                }</span>
        }
        <span class="cov0" title="0">return ""</span>
}
</pre>
		
		<pre class="file" id="file14" style="display: none">package model

import (
        "time"

        "gorm.io/datatypes"
)

// MovieCache は TMDb から取得した映画情報のキャッシュを表します。
// docs/data/database-schema.md の movie_cache テーブル定義に対応します。
type MovieCache struct {
        TmdbMovieID   int            `gorm:"type:integer;primaryKey;column:tmdb_movie_id" json:"tmdb_movie_id"`
        Title         string         `gorm:"type:text;not null" json:"title"`
        OriginalTitle *string        `gorm:"type:text;column:original_title" json:"original_title,omitempty"`
        PosterPath    *string        `gorm:"type:text;column:poster_path" json:"poster_path,omitempty"`
        BackdropPath  *string        `gorm:"type:text;column:backdrop_path" json:"backdrop_path,omitempty"`
        ReleaseDate   *time.Time     `gorm:"type:date;column:release_date" json:"release_date,omitempty"`
        VoteAverage   *float64       `gorm:"type:numeric(3,1);column:vote_average" json:"vote_average,omitempty"`
        Overview      *string        `gorm:"type:text" json:"overview,omitempty"`
        Genres        datatypes.JSON `gorm:"type:jsonb" json:"genres,omitempty"`
        Runtime       *int           `gorm:"type:integer" json:"runtime,omitempty"`
        CachedAt      time.Time      `gorm:"type:timestamptz;not null;default:CURRENT_TIMESTAMP;column:cached_at" json:"cached_at"`
        ExpiresAt     time.Time      `gorm:"type:timestamptz;not null;default:(CURRENT_TIMESTAMP + interval '7 days');column:expires_at" json:"expires_at"`
}

// TableName は対応するテーブル名を返します。
func (MovieCache) TableName() string <span class="cov0" title="0">{
        return "movie_cache"
}</span>
</pre>
		
		<pre class="file" id="file15" style="display: none">package model

import "time"

// Tag はユーザーが作成する映画タグを表します。
type Tag struct {
        ID             string    `gorm:"type:uuid;default:gen_random_uuid();primaryKey" json:"id"`
        UserID         string    `gorm:"type:uuid;not null;column:user_id" json:"user_id"`
        Title          string    `gorm:"type:text;not null" json:"title"`
        Description    *string   `gorm:"type:text" json:"description,omitempty"`
        CoverImageURL  *string   `gorm:"type:text;column:cover_image_url" json:"cover_image_url,omitempty"`
        IsPublic       bool      `gorm:"type:boolean;not null;default:false;column:is_public" json:"is_public"`
        AddMoviePolicy string    `gorm:"type:text;not null;default:'everyone';column:add_movie_policy" json:"add_movie_policy"`
        MovieCount     int       `gorm:"type:integer;not null;default:0;column:movie_count" json:"movie_count"`
        FollowerCount  int       `gorm:"type:integer;not null;default:0;column:follower_count" json:"follower_count"`
        CreatedAt      time.Time `gorm:"type:timestamptz;not null;default:CURRENT_TIMESTAMP;column:created_at" json:"created_at"`
        UpdatedAt      time.Time `gorm:"type:timestamptz;not null;default:CURRENT_TIMESTAMP;column:updated_at" json:"updated_at"`
}

// TableName は対応するテーブル名を返します。
func (Tag) TableName() string <span class="cov0" title="0">{
        return "tags"
}</span>
</pre>
		
		<pre class="file" id="file16" style="display: none">package model

import "time"

// TagFollower はタグのフォロー関係を表します。
// 旧 category_followers テーブルに相当します。
type TagFollower struct {
        TagID     string    `gorm:"type:uuid;primaryKey;column:tag_id" json:"tag_id"`
        UserID    string    `gorm:"type:uuid;primaryKey;column:user_id" json:"user_id"`
        CreatedAt time.Time `gorm:"type:timestamptz;not null;default:CURRENT_TIMESTAMP;column:created_at" json:"created_at"`
}

// TableName は対応するテーブル名を返します。
func (TagFollower) TableName() string <span class="cov0" title="0">{
        return "tag_followers"
}</span>


</pre>
		
		<pre class="file" id="file17" style="display: none">package model

import "time"

// TagMovie はタグに属する映画を表します。
// 旧 category_movies テーブルに相当し、tags と映画の関連を表現します。
type TagMovie struct {
        ID          string    `gorm:"type:uuid;default:gen_random_uuid();primaryKey" json:"id"`
        TagID       string    `gorm:"type:uuid;not null;column:tag_id;uniqueIndex:tag_movies_unique" json:"tag_id"`
        TmdbMovieID int       `gorm:"type:integer;not null;column:tmdb_movie_id;uniqueIndex:tag_movies_unique" json:"tmdb_movie_id"`
        AddedByUser string    `gorm:"type:uuid;not null;column:added_by_user_id" json:"added_by_user_id"`
        Note        *string   `gorm:"type:text" json:"note,omitempty"`
        Position    int       `gorm:"type:integer;not null;default:0" json:"position"`
        CreatedAt   time.Time `gorm:"type:timestamptz;not null;default:CURRENT_TIMESTAMP;column:created_at" json:"created_at"`
}

// TableName は対応するテーブル名を返します。
func (TagMovie) TableName() string <span class="cov0" title="0">{
        return "tag_movies"
}</span>


</pre>
		
		<pre class="file" id="file18" style="display: none">package model

import "time"

// User はサービスのユーザーを表すドメインモデルです。
// docs/data/database-schema.md の users テーブル定義に対応します。
type User struct {
        ID          string     `gorm:"type:uuid;default:gen_random_uuid();primaryKey" json:"id"`
        ClerkUserID string     `gorm:"type:text;not null;uniqueIndex:users_clerk_user_id_key;column:clerk_user_id" json:"clerk_user_id"`
        DisplayID   string     `gorm:"type:text;not null;uniqueIndex:users_display_id_key;column:display_id" json:"display_id"`
        DisplayName string     `gorm:"type:text;not null;column:display_name" json:"display_name"`
        Email       string     `gorm:"type:text;not null" json:"email"`
        AvatarURL   *string    `gorm:"type:text;column:avatar_url" json:"avatar_url,omitempty"`
        Bio         *string    `gorm:"type:text" json:"bio,omitempty"`
        CreatedAt   time.Time  `gorm:"type:timestamptz;not null;default:CURRENT_TIMESTAMP;column:created_at" json:"created_at"`
        UpdatedAt   time.Time  `gorm:"type:timestamptz;not null;default:CURRENT_TIMESTAMP;column:updated_at" json:"updated_at"`
        DeletedAt   *time.Time `gorm:"type:timestamptz;column:deleted_at" json:"deleted_at,omitempty"`
}

// TableName は対応するテーブル名を返します。
func (User) TableName() string <span class="cov0" title="0">{
        return "users"
}</span>
</pre>
		
		<pre class="file" id="file19" style="display: none">package model

import "time"

// UserFollower はユーザーのフォロー関係を表します。
type UserFollower struct {
        FollowerID string    `gorm:"type:uuid;primaryKey;column:follower_id" json:"follower_id"`
        FolloweeID string    `gorm:"type:uuid;primaryKey;column:followee_id" json:"followee_id"`
        CreatedAt  time.Time `gorm:"type:timestamptz;not null;default:CURRENT_TIMESTAMP;column:created_at" json:"created_at"`
}

// TableName は対応するテーブル名を返します。
func (UserFollower) TableName() string <span class="cov0" title="0">{
        return "user_followers"
}</span>
</pre>
		
		<pre class="file" id="file20" style="display: none">package repository

import (
        "context"

        "cinetag-backend/src/internal/model"

        "gorm.io/gorm"
)

// tag_followers テーブルの永続化処理を表すインターフェース。
type TagFollowerRepository interface {
        // Create はタグフォロー関係を作成します
        Create(ctx context.Context, tagID, userID string) error
        // Delete はタグフォロー関係を削除します
        Delete(ctx context.Context, tagID, userID string) error
        // DeleteAllByUserID は指定ユーザーに紐づくタグフォロー関係を全て削除します。
        DeleteAllByUserID(ctx context.Context, userID string) error
        // userID が tagID をフォローしているかチェックする。
        IsFollowing(ctx context.Context, tagID, userID string) (bool, error)
        // タグをフォローしているユーザー一覧を取得する。
        ListFollowers(ctx context.Context, tagID string, page, pageSize int) ([]*model.User, int64, error)
        // タグのフォロワー数を取得する。
        CountFollowers(ctx context.Context, tagID string) (int64, error)
        // ユーザーがフォローしているタグ一覧を取得する。
        ListFollowingTags(ctx context.Context, userID string, page, pageSize int) ([]*model.Tag, int64, error)
}

type tagFollowerRepository struct {
        db *gorm.DB
}

// TagFollowerRepository を生成する。
func NewTagFollowerRepository(db *gorm.DB) TagFollowerRepository <span class="cov0" title="0">{
        return &amp;tagFollowerRepository{db: db}
}</span>

// タグフォロー関係を作成する。
func (r *tagFollowerRepository) Create(ctx context.Context, tagID, userID string) error <span class="cov0" title="0">{
        follow := &amp;model.TagFollower{
                TagID:  tagID,
                UserID: userID,
        }
        return r.db.WithContext(ctx).Create(follow).Error
}</span>

// タグフォロー関係を削除する。
func (r *tagFollowerRepository) Delete(ctx context.Context, tagID, userID string) error <span class="cov0" title="0">{
        return r.db.WithContext(ctx).
                Where("tag_id = ? AND user_id = ?", tagID, userID).
                Delete(&amp;model.TagFollower{}).Error
}</span>

// 指定ユーザーに紐づくタグフォロー関係を全て削除する。
func (r *tagFollowerRepository) DeleteAllByUserID(ctx context.Context, userID string) error <span class="cov0" title="0">{
        return r.db.WithContext(ctx).
                Where("user_id = ?", userID).
                Delete(&amp;model.TagFollower{}).Error
}</span>

// userID が tagID をフォローしているかチェックする。
func (r *tagFollowerRepository) IsFollowing(ctx context.Context, tagID, userID string) (bool, error) <span class="cov0" title="0">{
        var count int64
        err := r.db.WithContext(ctx).
                Model(&amp;model.TagFollower{}).
                Where("tag_id = ? AND user_id = ?", tagID, userID).
                Count(&amp;count).Error
        if err != nil </span><span class="cov0" title="0">{
                return false, err
        }</span>
        <span class="cov0" title="0">return count &gt; 0, nil</span>
}

// タグをフォローしているユーザー一覧を取得する。
func (r *tagFollowerRepository) ListFollowers(ctx context.Context, tagID string, page, pageSize int) ([]*model.User, int64, error) <span class="cov0" title="0">{
        var users []*model.User
        var total int64

        offset := (page - 1) * pageSize

        // フォロワー数をカウント
        if err := r.db.WithContext(ctx).
                Model(&amp;model.TagFollower{}).
                Where("tag_id = ?", tagID).
                Count(&amp;total).Error; err != nil </span><span class="cov0" title="0">{
                return nil, 0, err
        }</span>

        // フォロワー一覧を取得
        <span class="cov0" title="0">err := r.db.WithContext(ctx).
                Table("users").
                Select("users.*").
                Joins("INNER JOIN tag_followers ON users.id = tag_followers.user_id").
                Where("tag_followers.tag_id = ?", tagID).
                Order("tag_followers.created_at DESC").
                Limit(pageSize).
                Offset(offset).
                Find(&amp;users).Error

        if err != nil </span><span class="cov0" title="0">{
                return nil, 0, err
        }</span>

        <span class="cov0" title="0">return users, total, nil</span>
}

// タグのフォロワー数を取得する。
func (r *tagFollowerRepository) CountFollowers(ctx context.Context, tagID string) (int64, error) <span class="cov0" title="0">{
        var count int64
        err := r.db.WithContext(ctx).
                Model(&amp;model.TagFollower{}).
                Where("tag_id = ?", tagID).
                Count(&amp;count).Error
        return count, err
}</span>

// ユーザーがフォローしているタグ一覧を取得する。
func (r *tagFollowerRepository) ListFollowingTags(ctx context.Context, userID string, page, pageSize int) ([]*model.Tag, int64, error) <span class="cov0" title="0">{
        var tags []*model.Tag
        var total int64

        offset := (page - 1) * pageSize

        // フォロー中のタグ数をカウント
        if err := r.db.WithContext(ctx).
                Model(&amp;model.TagFollower{}).
                Where("user_id = ?", userID).
                Count(&amp;total).Error; err != nil </span><span class="cov0" title="0">{
                return nil, 0, err
        }</span>

        // フォロー中のタグ一覧を取得（公開タグのみ）
        <span class="cov0" title="0">err := r.db.WithContext(ctx).
                Table("tags").
                Select("tags.*").
                Joins("INNER JOIN tag_followers ON tags.id = tag_followers.tag_id").
                Where("tag_followers.user_id = ? AND tags.is_public = ?", userID, true).
                Order("tag_followers.created_at DESC").
                Limit(pageSize).
                Offset(offset).
                Find(&amp;tags).Error

        if err != nil </span><span class="cov0" title="0">{
                return nil, 0, err
        }</span>

        <span class="cov0" title="0">return tags, total, nil</span>
}
</pre>
		
		<pre class="file" id="file21" style="display: none">package repository

import (
        "context"
        "errors"
        "time"

        "cinetag-backend/src/internal/model"

        "gorm.io/gorm"
        "gorm.io/gorm/clause"
)

var ErrTagMovieAlreadyExists = errors.New("tag movie already exists")

// タグに紐づく映画(TagMovie)に関する永続化処理を表すインターフェース。
type TagMovieRepository interface {
        // 指定したタグに紐づく映画を、追加順(新しい順)で最大 limit 件まで取得する。
        ListRecentByTag(ctx context.Context, tagID string, limit int) ([]model.TagMovie, error)
        // 指定したタグに紐づく映画を取得する（ページング対応）。
        // movie_cache を LEFT JOIN し、可能なら映画情報も一緒に返す。
        ListByTag(ctx context.Context, tagID string, offset, limit int) ([]TagMovieWithCache, int64, error)
        // タグに映画を追加する。
        // ユニーク制約違反（tag_movies_unique）の場合は ErrTagMovieAlreadyExists を返す。
        Create(ctx context.Context, tagMovie *model.TagMovie) error
        // 指定したIDのタグ映画を取得する。
        FindByID(ctx context.Context, tagMovieID string) (*model.TagMovie, error)
        // 指定したIDのタグ映画を削除する。
        Delete(ctx context.Context, tagMovieID string) error
        // 指定したタグに映画を追加したユーザー（参加者）を取得する。
        // タグ作成者(ownerID)は除外される。
        ListContributorsByTag(ctx context.Context, tagID string, ownerID string, limit int) ([]TagContributor, int64, error)
}

// タグに映画を追加したユーザー情報です。
type TagContributor struct {
        UserID      string  `gorm:"column:user_id"`
        DisplayID   string  `gorm:"column:display_id"`
        DisplayName string  `gorm:"column:display_name"`
        AvatarURL   *string `gorm:"column:avatar_url"`
}

// tag_movies と movie_cache の結合結果を表す。
// cache 側は存在しない可能性があるため nullable を許容する。
type TagMovieWithCache struct {
        ID          string    `gorm:"column:id"`
        TagID       string    `gorm:"column:tag_id"`
        TmdbMovieID int       `gorm:"column:tmdb_movie_id"`
        AddedByUser string    `gorm:"column:added_by_user_id"`
        Note        *string   `gorm:"column:note"`
        Position    int       `gorm:"column:position"`
        CreatedAt   time.Time `gorm:"column:created_at"`

        MovieTitle         *string    `gorm:"column:movie_title"`
        MovieOriginalTitle *string    `gorm:"column:movie_original_title"`
        MoviePosterPath    *string    `gorm:"column:movie_poster_path"`
        MovieReleaseDate   *time.Time `gorm:"column:movie_release_date"`
        MovieVoteAverage   *float64   `gorm:"column:movie_vote_average"`
}

// タグ映画に関する永続化処理を表すインターフェース。
type tagMovieRepository struct {
        db *gorm.DB
}

// TagMovieRepository の実装を生成する。
func NewTagMovieRepository(db *gorm.DB) TagMovieRepository <span class="cov0" title="0">{
        return &amp;tagMovieRepository{db: db}
}</span>

// 指定したタグに紐づく映画を、追加順(新しい順)で最大 limit 件まで取得する。
func (r *tagMovieRepository) ListRecentByTag(ctx context.Context, tagID string, limit int) ([]model.TagMovie, error) <span class="cov0" title="0">{
        if limit &lt;= 0 </span><span class="cov0" title="0">{
                return []model.TagMovie{}, nil
        }</span>

        <span class="cov0" title="0">var tagMovies []model.TagMovie
        if err := r.db.WithContext(ctx).
                Where("tag_id = ?", tagID).
                Order("created_at DESC").
                Limit(limit).
                Find(&amp;tagMovies).Error; err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">return tagMovies, nil</span>
}

// 指定したタグに紐づく映画を取得する（ページング対応）。
// movie_cache を LEFT JOIN し、可能なら映画情報も一緒に返す。
func (r *tagMovieRepository) ListByTag(ctx context.Context, tagID string, offset, limit int) ([]TagMovieWithCache, int64, error) <span class="cov0" title="0">{
        if limit &lt;= 0 </span><span class="cov0" title="0">{
                return []TagMovieWithCache{}, 0, nil
        }</span>
        <span class="cov0" title="0">if offset &lt; 0 </span><span class="cov0" title="0">{
                offset = 0
        }</span>

        // total count（tag_movies の件数）
        <span class="cov0" title="0">var total int64
        if err := r.db.WithContext(ctx).
                Model(&amp;model.TagMovie{}).
                Where("tag_id = ?", tagID).
                Count(&amp;total).Error; err != nil </span><span class="cov0" title="0">{
                return nil, 0, err
        }</span>
        <span class="cov0" title="0">if total == 0 </span><span class="cov0" title="0">{
                return []TagMovieWithCache{}, 0, nil
        }</span>

        // list with cache join
        <span class="cov0" title="0">var rows []TagMovieWithCache
        err := r.db.WithContext(ctx).
                Table((model.TagMovie{}).TableName()+" AS tm").
                Select(`tm.id, tm.tag_id, tm.tmdb_movie_id, tm.added_by_user_id, tm.note, tm.position, tm.created_at,
                        mc.title AS movie_title, mc.original_title AS movie_original_title, mc.poster_path AS movie_poster_path,
                        mc.release_date AS movie_release_date, mc.vote_average AS movie_vote_average`).
                Joins("LEFT JOIN "+(model.MovieCache{}).TableName()+" AS mc ON mc.tmdb_movie_id = tm.tmdb_movie_id").
                Where("tm.tag_id = ?", tagID).
                Order("tm.position ASC, tm.created_at DESC").
                Offset(offset).
                Limit(limit).
                Scan(&amp;rows).Error
        if err != nil </span><span class="cov0" title="0">{
                return nil, 0, err
        }</span>
        <span class="cov0" title="0">return rows, total, nil</span>
}

// タグに映画を追加する。
func (r *tagMovieRepository) Create(ctx context.Context, tagMovie *model.TagMovie) error <span class="cov0" title="0">{
        // ユニーク制約(tag_movies_unique)は (tag_id, tmdb_movie_id)。
        // 追加済みの場合はエラーにせず DoNothing にして RowsAffected で判定する。
        res := r.db.WithContext(ctx).Clauses(clause.OnConflict{
                Columns:   []clause.Column{{Name: "tag_id"}, {Name: "tmdb_movie_id"}},
                DoNothing: true,
        }).Create(tagMovie)

        if res.Error != nil </span><span class="cov0" title="0">{
                return res.Error
        }</span>
        <span class="cov0" title="0">if res.RowsAffected == 0 </span><span class="cov0" title="0">{
                return ErrTagMovieAlreadyExists
        }</span>
        <span class="cov0" title="0">return nil</span>
}

// 指定したIDのタグ映画を取得する。
func (r *tagMovieRepository) FindByID(ctx context.Context, tagMovieID string) (*model.TagMovie, error) <span class="cov0" title="0">{
        var tagMovie model.TagMovie
        if err := r.db.WithContext(ctx).Where("id = ?", tagMovieID).First(&amp;tagMovie).Error; err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return &amp;tagMovie, nil</span>
}

// 指定したIDのタグ映画を削除する。
func (r *tagMovieRepository) Delete(ctx context.Context, tagMovieID string) error <span class="cov0" title="0">{
        return r.db.WithContext(ctx).Where("id = ?", tagMovieID).Delete(&amp;model.TagMovie{}).Error
}</span>

// 指定したタグに映画を追加したユーザー（参加者）を取得する。
// タグ作成者(ownerID)は除外される。
func (r *tagMovieRepository) ListContributorsByTag(ctx context.Context, tagID string, ownerID string, limit int) ([]TagContributor, int64, error) <span class="cov0" title="0">{
        if limit &lt;= 0 </span><span class="cov0" title="0">{
                limit = 10
        }</span>

        // サブクエリで distinct なユーザーIDを取得（タグ作成者は除外）
        // total count
        <span class="cov0" title="0">var total int64
        countQuery := r.db.WithContext(ctx).
                Table((model.TagMovie{}).TableName()).
                Select("COUNT(DISTINCT added_by_user_id)").
                Where("tag_id = ?", tagID).
                Where("added_by_user_id != ?", ownerID)
        if err := countQuery.Scan(&amp;total).Error; err != nil </span><span class="cov0" title="0">{
                return nil, 0, err
        }</span>
        <span class="cov0" title="0">if total == 0 </span><span class="cov0" title="0">{
                return []TagContributor{}, 0, nil
        }</span>

        // ユーザー情報を取得（GROUP BYでユニーク化し、最初に追加した日時順でソート）
        <span class="cov0" title="0">var rows []TagContributor
        err := r.db.WithContext(ctx).
                Table((model.TagMovie{}).TableName()+" AS tm").
                Select("u.id AS user_id, u.display_id, u.display_name, u.avatar_url").
                Joins("JOIN "+(model.User{}).TableName()+" AS u ON u.id = tm.added_by_user_id").
                Where("tm.tag_id = ?", tagID).
                Where("tm.added_by_user_id != ?", ownerID).
                Group("u.id, u.display_id, u.display_name, u.avatar_url").
                Order("MIN(tm.created_at) ASC").
                Limit(limit).
                Scan(&amp;rows).Error
        if err != nil </span><span class="cov0" title="0">{
                return nil, 0, err
        }</span>

        <span class="cov0" title="0">return rows, total, nil</span>
}
</pre>
		
		<pre class="file" id="file22" style="display: none">package repository

import (
        "context"
        "errors"
        "time"

        "cinetag-backend/src/internal/model"

        "gorm.io/gorm"
)

// 公開タグ一覧取得時のフィルタ条件を表す。
type TagListFilter struct {
        Query  string
        Sort   string
        Offset int
        Limit  int
}

// 公開タグ一覧取得時に返す1件分の情報（DB由来部分）を表す。
type TagSummary struct {
        ID              string    `gorm:"column:id"`
        Title           string    `gorm:"column:title"`
        Description     *string   `gorm:"column:description"`
        CoverImageURL   *string   `gorm:"column:cover_image_url"`
        IsPublic        bool      `gorm:"column:is_public"`
        MovieCount      int       `gorm:"column:movie_count"`
        FollowerCount   int       `gorm:"column:follower_count"`
        CreatedAt       time.Time `gorm:"column:created_at"`
        Author          string    `gorm:"column:author"`
        AuthorDisplayID string    `gorm:"column:author_display_id"`
}

// タグ詳細取得時に返すDB由来の情報を表す。
// owner 情報を users と JOIN して取得します。
type TagDetailRow struct {
        ID             string    `gorm:"column:id"`
        Title          string    `gorm:"column:title"`
        Description    *string   `gorm:"column:description"`
        CoverImageURL  *string   `gorm:"column:cover_image_url"`
        IsPublic       bool      `gorm:"column:is_public"`
        AddMoviePolicy string    `gorm:"column:add_movie_policy"`
        MovieCount     int       `gorm:"column:movie_count"`
        FollowerCount  int       `gorm:"column:follower_count"`
        CreatedAt      time.Time `gorm:"column:created_at"`
        UpdatedAt      time.Time `gorm:"column:updated_at"`

        OwnerID          string  `gorm:"column:owner_id"`
        OwnerDisplayID   string  `gorm:"column:owner_display_id"`
        OwnerDisplayName string  `gorm:"column:owner_display_name"`
        OwnerAvatarURL   *string `gorm:"column:owner_avatar_url"`
}

// ユーザーのタグ一覧取得時のフィルタ条件を表す。
type UserTagListFilter struct {
        UserID        string
        IncludePublic bool // trueなら公開タグのみ、falseなら全て（自分のページ用）
        Offset        int
        Limit         int
}

// タグに関する永続化処理を表すインターフェース。
type TagRepository interface {
        Create(ctx context.Context, tag *model.Tag) error
        FindByID(ctx context.Context, id string) (*model.Tag, error)
        FindDetailByID(ctx context.Context, id string) (*TagDetailRow, error)
        UpdateByID(ctx context.Context, id string, patch TagUpdatePatch) error
        IncrementMovieCount(ctx context.Context, id string, delta int) error
        ListPublicTags(ctx context.Context, filter TagListFilter) ([]TagSummary, int64, error)
        ListTagsByUserID(ctx context.Context, filter UserTagListFilter) ([]TagSummary, int64, error)
}

type tagRepository struct {
        db *gorm.DB
}

// tags テーブルの部分更新に利用する。
// nil のフィールドは更新しません。
type TagUpdatePatch struct {
        Title          *string
        Description    **string
        CoverImageURL  **string
        IsPublic       *bool
        AddMoviePolicy *string
}

// TagRepository の実装を生成する。
func NewTagRepository(db *gorm.DB) TagRepository <span class="cov0" title="0">{
        return &amp;tagRepository{db: db}
}</span>

// タグを作成する。
func (r *tagRepository) Create(ctx context.Context, tag *model.Tag) error <span class="cov0" title="0">{
        return r.db.WithContext(ctx).Create(tag).Error
}</span>

// 指定IDのタグを取得する。
func (r *tagRepository) FindByID(ctx context.Context, id string) (*model.Tag, error) <span class="cov0" title="0">{
        var tag model.Tag
        err := r.db.WithContext(ctx).Where("id = ?", id).First(&amp;tag).Error
        if err != nil </span><span class="cov0" title="0">{
                if errors.Is(err, gorm.ErrRecordNotFound) </span><span class="cov0" title="0">{
                        return nil, gorm.ErrRecordNotFound
                }</span>
                <span class="cov0" title="0">return nil, err</span>
        }
        <span class="cov0" title="0">return &amp;tag, nil</span>
}

// 指定IDのタグの詳細を取得する。
func (r *tagRepository) FindDetailByID(ctx context.Context, id string) (*TagDetailRow, error) <span class="cov0" title="0">{
        var row TagDetailRow
        err := r.db.WithContext(ctx).
                Table((model.Tag{}).TableName()+" AS t").
                Select(`t.id, t.title, t.description, t.cover_image_url, t.is_public, t.add_movie_policy,
                                t.movie_count, t.follower_count, t.created_at, t.updated_at,
                                u.id AS owner_id, u.display_id AS owner_display_id,
                                u.display_name AS owner_display_name, u.avatar_url AS owner_avatar_url`).
                Joins("JOIN "+(model.User{}).TableName()+" AS u ON u.id = t.user_id").
                Where("t.id = ?", id).
                Scan(&amp;row).
                Error
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">if row.ID == "" </span><span class="cov0" title="0">{
                return nil, gorm.ErrRecordNotFound
        }</span>
        <span class="cov0" title="0">return &amp;row, nil</span>
}

// 指定IDのタグを更新する。
func (r *tagRepository) UpdateByID(ctx context.Context, id string, patch TagUpdatePatch) error <span class="cov0" title="0">{
        updates := map[string]any{}
        if patch.Title != nil </span><span class="cov0" title="0">{
                updates["title"] = *patch.Title
        }</span>
        <span class="cov0" title="0">if patch.Description != nil </span><span class="cov0" title="0">{
                updates["description"] = *patch.Description
        }</span>
        <span class="cov0" title="0">if patch.CoverImageURL != nil </span><span class="cov0" title="0">{
                updates["cover_image_url"] = *patch.CoverImageURL
        }</span>
        <span class="cov0" title="0">if patch.IsPublic != nil </span><span class="cov0" title="0">{
                updates["is_public"] = *patch.IsPublic
        }</span>
        <span class="cov0" title="0">if patch.AddMoviePolicy != nil </span><span class="cov0" title="0">{
                updates["add_movie_policy"] = *patch.AddMoviePolicy
        }</span>

        <span class="cov0" title="0">if len(updates) == 0 </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov0" title="0">return r.db.WithContext(ctx).
                Model(&amp;model.Tag{}).
                Where("id = ?", id).
                Updates(updates).
                Error</span>
}

// 指定IDのタグの映画数を増やす。
func (r *tagRepository) IncrementMovieCount(ctx context.Context, id string, delta int) error <span class="cov0" title="0">{
        if delta == 0 </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov0" title="0">return r.db.WithContext(ctx).
                Model(&amp;model.Tag{}).
                Where("id = ?", id).
                UpdateColumn("movie_count", gorm.Expr("movie_count + ?", delta)).
                Error</span>
}

// 公開タグ一覧を取得する。
func (r *tagRepository) ListPublicTags(ctx context.Context, filter TagListFilter) ([]TagSummary, int64, error) <span class="cov0" title="0">{
        if filter.Limit &lt;= 0 </span><span class="cov0" title="0">{
                return []TagSummary{}, 0, nil
        }</span>

        <span class="cov0" title="0">baseQuery := r.db.WithContext(ctx).
                Table((model.Tag{}).TableName()+" AS t").
                Joins("JOIN "+(model.User{}).TableName()+" AS u ON u.id = t.user_id").
                Where("t.is_public = ?", true)

        if filter.Query != "" </span><span class="cov0" title="0">{
                baseQuery = baseQuery.Where("t.title ILIKE ?", "%"+filter.Query+"%")
        }</span>

        <span class="cov0" title="0">var total int64
        if err := baseQuery.Count(&amp;total).Error; err != nil </span><span class="cov0" title="0">{
                return nil, 0, err
        }</span>
        <span class="cov0" title="0">if total == 0 </span><span class="cov0" title="0">{
                return []TagSummary{}, 0, nil
        }</span>

        // Count()はSELECTをCOUNT(*)に置き換えるため、Select句を再指定
        <span class="cov0" title="0">qb := baseQuery.Select(`t.id, t.title, t.description, t.cover_image_url, t.is_public,
                                t.movie_count, t.follower_count, t.created_at,
                                u.display_name AS author, u.display_id AS author_display_id`)

        switch filter.Sort </span>{
        case "recent":<span class="cov0" title="0">
                qb = qb.Order("t.created_at DESC")</span>
        case "movie_count":<span class="cov0" title="0">
                qb = qb.Order("t.movie_count DESC")</span>
        default:<span class="cov0" title="0">
                qb = qb.Order("t.follower_count DESC")</span>
        }

        <span class="cov0" title="0">var rows []TagSummary
        if err := qb.Limit(filter.Limit).Offset(filter.Offset).Scan(&amp;rows).Error; err != nil </span><span class="cov0" title="0">{
                return nil, 0, err
        }</span>

        <span class="cov0" title="0">return rows, total, nil</span>
}

// 指定ユーザーのタグ一覧を取得する。
func (r *tagRepository) ListTagsByUserID(ctx context.Context, filter UserTagListFilter) ([]TagSummary, int64, error) <span class="cov0" title="0">{
        if filter.Limit &lt;= 0 </span><span class="cov0" title="0">{
                return []TagSummary{}, 0, nil
        }</span>

        <span class="cov0" title="0">baseQuery := r.db.WithContext(ctx).
                Table((model.Tag{}).TableName()+" AS t").
                Joins("JOIN "+(model.User{}).TableName()+" AS u ON u.id = t.user_id").
                Where("t.user_id = ?", filter.UserID)

        // 公開タグのみにフィルタ（他ユーザーのページ閲覧時）
        if filter.IncludePublic </span><span class="cov0" title="0">{
                baseQuery = baseQuery.Where("t.is_public = ?", true)
        }</span>

        <span class="cov0" title="0">var total int64
        if err := baseQuery.Count(&amp;total).Error; err != nil </span><span class="cov0" title="0">{
                return nil, 0, err
        }</span>
        <span class="cov0" title="0">if total == 0 </span><span class="cov0" title="0">{
                return []TagSummary{}, 0, nil
        }</span>

        // Count()はSELECTをCOUNT(*)に置き換えるため、Select句を再指定
        <span class="cov0" title="0">qb := baseQuery.Select(`t.id, t.title, t.description, t.cover_image_url, t.is_public,
                                t.movie_count, t.follower_count, t.created_at,
                                u.display_name AS author, u.display_id AS author_display_id`).
                Order("t.created_at DESC")

        var rows []TagSummary
        if err := qb.Limit(filter.Limit).Offset(filter.Offset).Scan(&amp;rows).Error; err != nil </span><span class="cov0" title="0">{
                return nil, 0, err
        }</span>

        <span class="cov0" title="0">return rows, total, nil</span>
}
</pre>
		
		<pre class="file" id="file23" style="display: none">package repository

import (
        "context"

        "cinetag-backend/src/internal/model"

        "gorm.io/gorm"
)

// user_followers テーブルの永続化処理を表すインターフェース。
type UserFollowerRepository interface {
        // フォロー関係を作成する。
        Create(ctx context.Context, followerID, followeeID string) error
        // フォロー関係を削除する。
        Delete(ctx context.Context, followerID, followeeID string) error
        // 指定ユーザーが関与するフォロー関係を全て削除する。
        // （follower / followee の両方を対象とします）
        DeleteAllByUserID(ctx context.Context, userID string) error
        // followerID が followeeID をフォローしているかチェックする。
        IsFollowing(ctx context.Context, followerID, followeeID string) (bool, error)
        // 指定ユーザーがフォローしているユーザー一覧を取得する。
        ListFollowing(ctx context.Context, userID string, page, pageSize int) ([]*model.User, int64, error)
        // 指定ユーザーをフォローしているユーザー一覧を取得する。
        ListFollowers(ctx context.Context, userID string, page, pageSize int) ([]*model.User, int64, error)
        // 指定ユーザーがフォローしているユーザー数を取得する。
        CountFollowing(ctx context.Context, userID string) (int64, error)
        // 指定ユーザーのフォロワー数を取得する。
        CountFollowers(ctx context.Context, userID string) (int64, error)
}

type userFollowerRepository struct {
        db *gorm.DB
}

// UserFollowerRepository の実装を生成する。
func NewUserFollowerRepository(db *gorm.DB) UserFollowerRepository <span class="cov0" title="0">{
        return &amp;userFollowerRepository{db: db}
}</span>

// フォロー関係を作成する。
func (r *userFollowerRepository) Create(ctx context.Context, followerID, followeeID string) error <span class="cov0" title="0">{
        follow := &amp;model.UserFollower{
                FollowerID: followerID,
                FolloweeID: followeeID,
        }
        return r.db.WithContext(ctx).Create(follow).Error
}</span>

// フォロー関係を削除する。
func (r *userFollowerRepository) Delete(ctx context.Context, followerID, followeeID string) error <span class="cov0" title="0">{
        return r.db.WithContext(ctx).
                Where("follower_id = ? AND followee_id = ?", followerID, followeeID).
                Delete(&amp;model.UserFollower{}).Error
}</span>

// 指定ユーザーが関与するフォロー関係を全て削除する。
func (r *userFollowerRepository) DeleteAllByUserID(ctx context.Context, userID string) error <span class="cov0" title="0">{
        return r.db.WithContext(ctx).
                Where("follower_id = ? OR followee_id = ?", userID, userID).
                Delete(&amp;model.UserFollower{}).Error
}</span>

// followerID が followeeID をフォローしているかチェックする。
func (r *userFollowerRepository) IsFollowing(ctx context.Context, followerID, followeeID string) (bool, error) <span class="cov0" title="0">{
        var count int64
        err := r.db.WithContext(ctx).
                Model(&amp;model.UserFollower{}).
                Where("follower_id = ? AND followee_id = ?", followerID, followeeID).
                Count(&amp;count).Error
        if err != nil </span><span class="cov0" title="0">{
                return false, err
        }</span>
        <span class="cov0" title="0">return count &gt; 0, nil</span>
}

// 指定ユーザーがフォローしているユーザー一覧を取得する。
func (r *userFollowerRepository) ListFollowing(ctx context.Context, userID string, page, pageSize int) ([]*model.User, int64, error) <span class="cov0" title="0">{
        var users []*model.User
        var total int64

        offset := (page - 1) * pageSize

        // フォロー中のユーザー数をカウント
        if err := r.db.WithContext(ctx).
                Model(&amp;model.UserFollower{}).
                Where("follower_id = ?", userID).
                Count(&amp;total).Error; err != nil </span><span class="cov0" title="0">{
                return nil, 0, err
        }</span>

        // フォロー中のユーザー一覧を取得
        <span class="cov0" title="0">err := r.db.WithContext(ctx).
                Table("users").
                Select("users.*").
                Joins("INNER JOIN user_followers ON users.id = user_followers.followee_id").
                Where("user_followers.follower_id = ?", userID).
                Order("user_followers.created_at DESC").
                Limit(pageSize).
                Offset(offset).
                Find(&amp;users).Error

        if err != nil </span><span class="cov0" title="0">{
                return nil, 0, err
        }</span>

        <span class="cov0" title="0">return users, total, nil</span>
}

// 指定ユーザーをフォローしているユーザー一覧を取得する。
func (r *userFollowerRepository) ListFollowers(ctx context.Context, userID string, page, pageSize int) ([]*model.User, int64, error) <span class="cov0" title="0">{
        var users []*model.User
        var total int64

        offset := (page - 1) * pageSize

        // フォロワー数をカウント
        if err := r.db.WithContext(ctx).
                Model(&amp;model.UserFollower{}).
                Where("followee_id = ?", userID).
                Count(&amp;total).Error; err != nil </span><span class="cov0" title="0">{
                return nil, 0, err
        }</span>

        // フォロワー一覧を取得
        <span class="cov0" title="0">err := r.db.WithContext(ctx).
                Table("users").
                Select("users.*").
                Joins("INNER JOIN user_followers ON users.id = user_followers.follower_id").
                Where("user_followers.followee_id = ?", userID).
                Order("user_followers.created_at DESC").
                Limit(pageSize).
                Offset(offset).
                Find(&amp;users).Error

        if err != nil </span><span class="cov0" title="0">{
                return nil, 0, err
        }</span>

        <span class="cov0" title="0">return users, total, nil</span>
}

// 指定ユーザーがフォローしているユーザー数を取得する。
func (r *userFollowerRepository) CountFollowing(ctx context.Context, userID string) (int64, error) <span class="cov0" title="0">{
        var count int64
        err := r.db.WithContext(ctx).
                Model(&amp;model.UserFollower{}).
                Where("follower_id = ?", userID).
                Count(&amp;count).Error
        return count, err
}</span>

// 指定ユーザーのフォロワー数を取得する。
func (r *userFollowerRepository) CountFollowers(ctx context.Context, userID string) (int64, error) <span class="cov0" title="0">{
        var count int64
        err := r.db.WithContext(ctx).
                Model(&amp;model.UserFollower{}).
                Where("followee_id = ?", userID).
                Count(&amp;count).Error
        return count, err
}</span>
</pre>
		
		<pre class="file" id="file24" style="display: none">package repository

import (
        "context"
        "log/slog"
        "time"

        "cinetag-backend/src/internal/model"

        "gorm.io/gorm"
)

// users テーブルの永続化処理を表すインターフェース。
type UserRepository interface {
        FindByID(ctx context.Context, userID string) (*model.User, error)
        FindByClerkUserID(ctx context.Context, clerkUserID string) (*model.User, error)
        FindByDisplayID(ctx context.Context, displayID string) (*model.User, error)
        Create(ctx context.Context, user *model.User) error
        UpdateForUserDeactivated(ctx context.Context, userID string, now time.Time, anonymizedEmail string) error
}

type userRepository struct {
        logger *slog.Logger
        db     *gorm.DB
}

// UserRepository の実装を生成する。
func NewUserRepository(logger *slog.Logger, db *gorm.DB) UserRepository <span class="cov0" title="0">{
        return &amp;userRepository{
                logger: logger,
                db:     db,
        }
}</span>

// userID からユーザー情報を取得する。
func (r *userRepository) FindByID(ctx context.Context, userID string) (*model.User, error) <span class="cov0" title="0">{
        var user model.User
        if err := r.db.WithContext(ctx).Where("id = ?", userID).First(&amp;user).Error; err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return &amp;user, nil</span>
}

// clerk_user_id からユーザー情報を取得する。
func (r *userRepository) FindByClerkUserID(ctx context.Context, clerkUserID string) (*model.User, error) <span class="cov0" title="0">{
        var user model.User
        if err := r.db.WithContext(ctx).Where("clerk_user_id = ?", clerkUserID).First(&amp;user).Error; err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return &amp;user, nil</span>
}

// display_id からユーザー情報を取得する。
func (r *userRepository) FindByDisplayID(ctx context.Context, displayID string) (*model.User, error) <span class="cov0" title="0">{
        // 開始ログ（DEBUG）
        r.logger.Debug("repository.FindByDisplayID started",
                slog.String("display_id", displayID),
        )
        var user model.User
        if err := r.db.WithContext(ctx).Where("display_id = ?", displayID).First(&amp;user).Error; err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return &amp;user, nil</span>
}

// ユーザーを作成する。
func (r *userRepository) Create(ctx context.Context, user *model.User) error <span class="cov0" title="0">{
        return r.db.WithContext(ctx).Create(user).Error
}</span>

// ユーザーを論理削除＋匿名化する。
func (r *userRepository) UpdateForUserDeactivated(ctx context.Context, userID string, now time.Time, anonymizedEmail string) error <span class="cov0" title="0">{
        updates := map[string]any{
                "deleted_at":   now,
                "display_name": "退会済みユーザー",
                "avatar_url":   nil,
                "bio":          nil,
                "email":        anonymizedEmail,
                "updated_at":   now,
        }

        return r.db.WithContext(ctx).
                Model(&amp;model.User{}).
                Where("id = ?", userID).
                Updates(updates).
                Error
}</span>
</pre>
		
		<pre class="file" id="file25" style="display: none">package seed

import (
        "fmt"
        "os"
        "strings"

        "cinetag-backend/src/internal/model"

        "gorm.io/gorm"
        "gorm.io/gorm/clause"
)

const (
        seedTagID = "154c44ab-3ba9-4c26-9642-49d11d3d1ff5"
)

func isDevelop() bool <span class="cov0" title="0">{
        return strings.TrimSpace(strings.ToLower(os.Getenv("ENV"))) == "develop"
}</span>

// 開発環境（ENV=develop）のときだけ、開発用のseedデータを投入する。
//
// 何度実行しても整合性が壊れないよう、ユニーク制約を利用した upsert / do-nothing で冪等化する。
func SeedDevelop(db *gorm.DB) error <span class="cov0" title="0">{
        if !isDevelop() </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov0" title="0">return db.Transaction(func(tx *gorm.DB) error </span><span class="cov0" title="0">{
                creatorID, err := upsertUser(tx, model.User{
                        ClerkUserID: "user_376ohwfbOYMZnEyFXrIpZpRzU0h", // clerkに登録済みのユーザーID
                        DisplayID:   "demo01",
                        DisplayName: "デモ01",
                        Email:       "demo01@example.com",
                })
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("upsert seed creator: %w", err)
                }</span>

                <span class="cov0" title="0">followerID, err := upsertUser(tx, model.User{
                        ClerkUserID: "user_376ozoBYiBZiFipgkEerZGXCjMm",
                        DisplayID:   "demo02",
                        DisplayName: "デモ02",
                        Email:       "demo02@example.com",
                })
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("upsert seed follower: %w", err)
                }</span>

                <span class="cov0" title="0">tagDescription := "開発用seedタグです。migrate実行で自動投入されます。"
                seedTag := model.Tag{
                        ID:          seedTagID,
                        UserID:      creatorID,
                        Title:       "Seed Tag",
                        Description: &amp;tagDescription,
                        IsPublic:    true,
                }
                if err := tx.Clauses(clause.OnConflict{
                        Columns: []clause.Column{{Name: "id"}},
                        DoUpdates: clause.AssignmentColumns([]string{
                                "user_id",
                                "title",
                                "description",
                                "cover_image_url",
                                "is_public",
                        }),
                }).Create(&amp;seedTag).Error; err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("upsert seed tag: %w", err)
                }</span>

                <span class="cov0" title="0">movies := []struct {
                        tmdbID   int
                        position int
                        note     *string
                }{
                        {tmdbID: 550, position: 0, note: strPtr("Fight Club")},
                        {tmdbID: 603, position: 1, note: strPtr("The Matrix")},
                        {tmdbID: 155, position: 2, note: strPtr("The Dark Knight")},
                        {tmdbID: 680, position: 3, note: strPtr("Pulp Fiction")},
                        {tmdbID: 27205, position: 4, note: strPtr("Inception")},
                }

                for _, m := range movies </span><span class="cov0" title="0">{
                        tm := model.TagMovie{
                                TagID:       seedTagID,
                                TmdbMovieID: m.tmdbID,
                                AddedByUser: creatorID,
                                Note:        m.note,
                                Position:    m.position,
                        }
                        if err := tx.Clauses(clause.OnConflict{
                                Columns: []clause.Column{{Name: "tag_id"}, {Name: "tmdb_movie_id"}},
                                DoUpdates: clause.AssignmentColumns([]string{
                                        "added_by_user_id",
                                        "note",
                                        "position",
                                }),
                        }).Create(&amp;tm).Error; err != nil </span><span class="cov0" title="0">{
                                return fmt.Errorf("upsert seed tag_movies (tmdb=%d): %w", m.tmdbID, err)
                        }</span>
                }

                <span class="cov0" title="0">follow := model.TagFollower{
                        TagID:  seedTagID,
                        UserID: followerID,
                }
                if err := tx.Clauses(clause.OnConflict{
                        Columns:   []clause.Column{{Name: "tag_id"}, {Name: "user_id"}},
                        DoNothing: true,
                }).Create(&amp;follow).Error; err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("insert seed tag_follower: %w", err)
                }</span>

                <span class="cov0" title="0">return nil</span>
        })
}

func upsertUser(tx *gorm.DB, u model.User) (string, error) <span class="cov0" title="0">{
        if err := tx.Clauses(clause.OnConflict{
                Columns: []clause.Column{{Name: "clerk_user_id"}},
                DoUpdates: clause.AssignmentColumns([]string{
                        "display_id",
                        "display_name",
                        "email",
                        "avatar_url",
                        "bio",
                }),
        }).Create(&amp;u).Error; err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>

        <span class="cov0" title="0">var out model.User
        if err := tx.Where("clerk_user_id = ?", u.ClerkUserID).First(&amp;out).Error; err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>
        <span class="cov0" title="0">return out.ID, nil</span>
}

func strPtr(s string) *string <span class="cov0" title="0">{
        return &amp;s
}</span>
</pre>
		
		<pre class="file" id="file26" style="display: none">package service

import (
        "errors"
        "strings"
)

var (
        ErrClerkUserInfoInvalid = errors.New("invalid clerk user info")
)

// Webhook の生フィールドから ClerkUserInfo を構築します。
func NewClerkUserInfoFromWebhook(id, email, firstName, lastName string, imageURL *string) (ClerkUserInfo, error) <span class="cov0" title="0">{
        id = strings.TrimSpace(id)
        email = strings.TrimSpace(email)
        firstName = strings.TrimSpace(firstName)
        lastName = strings.TrimSpace(lastName)

        if id == "" || email == "" </span><span class="cov0" title="0">{
                return ClerkUserInfo{}, ErrClerkUserInfoInvalid
        }</span>

        <span class="cov0" title="0">return ClerkUserInfo{
                ID:        id,
                Email:     email,
                FirstName: firstName,
                LastName:  lastName,
                AvatarURL: trimStringPtr(imageURL),
        }, nil</span>
}

// NewClerkUserInfoFromJWTClaims は JWT claims から ClerkUserInfo を構築します。
// - ID: claim["sub"]
// - Email: claim["email"]
// - FirstName: claim["first_name"]
// - LastName: claim["last_name"]
// - AvatarURL: claim["image_url"]
//
// Email は必須です（空の場合は error を返します）。
func NewClerkUserInfoFromJWTClaims(claims map[string]any) (ClerkUserInfo, error) <span class="cov0" title="0">{
        sub := trimStringClaim(claims, "sub")
        email := trimStringClaim(claims, "email")
        firstName := trimStringClaim(claims, "first_name")
        lastName := trimStringClaim(claims, "last_name")
        imageURL := trimStringClaimPtr(claims, "image_url")

        if sub == "" || email == "" </span><span class="cov0" title="0">{
                return ClerkUserInfo{}, ErrClerkUserInfoInvalid
        }</span>

        <span class="cov0" title="0">return ClerkUserInfo{
                ID:        sub,
                Email:     email,
                FirstName: firstName,
                LastName:  lastName,
                AvatarURL: imageURL,
        }, nil</span>
}

func trimStringClaim(claims map[string]any, key string) string <span class="cov0" title="0">{
        v, ok := claims[key].(string)
        if !ok </span><span class="cov0" title="0">{
                return ""
        }</span>
        <span class="cov0" title="0">return strings.TrimSpace(v)</span>
}

func trimStringClaimPtr(claims map[string]any, key string) *string <span class="cov0" title="0">{
        s := trimStringClaim(claims, key)
        if s == "" </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov0" title="0">return &amp;s</span>
}

func trimStringPtr(s *string) *string <span class="cov0" title="0">{
        if s == nil </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov0" title="0">v := strings.TrimSpace(*s)
        if v == "" </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov0" title="0">return &amp;v</span>
}
</pre>
		
		<pre class="file" id="file27" style="display: none">package service

import (
        "context"
        "math/rand"

        "cinetag-backend/src/internal/repository"
)

const (
        userDisplayIDPrefix    = "user-"
        userDisplayIDSuffixLen = 6
        userDisplayIDChars     = "abcdefghijklmnopqrstuvwxyz0123456789"
)

// 指定長のランダム英数字を生成して返す。
func generateRandomString(n int) string <span class="cov8" title="1">{
        b := make([]byte, n)
        for i := range b </span><span class="cov8" title="1">{
                b[i] = userDisplayIDChars[rand.Intn(len(userDisplayIDChars))]
        }</span>
        <span class="cov8" title="1">return string(b)</span>
}

// user display_id を生成する。
// 重複がないかチェックし、重複していたら再帰的に生成し直します。
func generateUniqueUserDisplayID(ctx context.Context, userRepo repository.UserRepository) string <span class="cov8" title="1">{
        displayID := userDisplayIDPrefix + generateRandomString(userDisplayIDSuffixLen)

        if IsValidUserDisplayID(ctx, userRepo, displayID) </span><span class="cov8" title="1">{
                return displayID
        }</span>
        <span class="cov8" title="1">return generateUniqueUserDisplayID(ctx, userRepo)</span>
}

// user display_id を生成する。
func GenerateUserDisplayID(ctx context.Context, userRepo repository.UserRepository) string <span class="cov8" title="1">{
        return generateUniqueUserDisplayID(ctx, userRepo)
}</span>

// user display_id が有効かチェックする。
func IsValidUserDisplayID(ctx context.Context, userRepo repository.UserRepository, displayID string) bool <span class="cov8" title="1">{
        // user display_id がすでに存在する場合は無効。
        if _, err := userRepo.FindByDisplayID(ctx, displayID); err == nil </span><span class="cov8" title="1">{
                return false
        }</span>
        <span class="cov8" title="1">return true</span>
}
</pre>
		
		<pre class="file" id="file28" style="display: none">package service

import (
        "context"
        "encoding/json"
        "errors"
        "fmt"
        "log/slog"
        "net/http"
        "net/url"
        "os"
        "path"
        "strconv"
        "strings"
        "time"

        "cinetag-backend/src/internal/model"

        "gorm.io/datatypes"
        "gorm.io/gorm"
        "gorm.io/gorm/clause"
)

type MovieService interface {
        // 指定した TMDB 映画 ID に対応する movie_cache レコードの存在と有効期限を保証する。
        // - 有効なキャッシュがあればそれを返す
        // - キャッシュが無い、または期限切れの場合は TMDB から取得してキャッシュを更新する
        EnsureMovieCache(ctx context.Context, tmdbMovieID int) (*model.MovieCache, error)

        // TMDB の検索APIで映画を検索し、候補一覧を返す。
        SearchMovies(ctx context.Context, query string, page int) ([]TMDBSearchResult, int, error)
}

// TMDB 連携に必要な設定値。
type TMDBConfig struct {
        APIKey          string
        BaseURL         string
        DefaultLanguage string
}

// MovieService の実装です。
type movieService struct {
        logger     *slog.Logger
        db         *gorm.DB
        httpClient *http.Client
        cfg        TMDBConfig
}

// MovieService を生成する。
func NewMovieService(logger *slog.Logger, db *gorm.DB) MovieService <span class="cov0" title="0">{
        cfg := TMDBConfig{
                APIKey:          os.Getenv("TMDB_API_KEY"),
                BaseURL:         os.Getenv("TMDB_BASE_URL"),
                DefaultLanguage: os.Getenv("TMDB_DEFAULT_LANGUAGE"),
        }

        if cfg.BaseURL == "" </span><span class="cov0" title="0">{
                cfg.BaseURL = "https://api.themoviedb.org/3"
        }</span>
        <span class="cov0" title="0">if cfg.DefaultLanguage == "" </span><span class="cov0" title="0">{
                cfg.DefaultLanguage = "ja-JP"
        }</span>

        <span class="cov0" title="0">return &amp;movieService{
                logger: logger,
                db:     db,
                httpClient: &amp;http.Client{
                        Timeout: 5 * time.Second,
                },
                cfg: cfg,
        }</span>
}

// テストや将来の拡張用に、設定と HTTP クライアントを外部から注入するためのコンストラクタ。
func NewMovieServiceWithConfig(db *gorm.DB, cfg TMDBConfig, client *http.Client) MovieService <span class="cov0" title="0">{
        if cfg.BaseURL == "" </span><span class="cov0" title="0">{
                cfg.BaseURL = "https://api.themoviedb.org/3"
        }</span>
        <span class="cov0" title="0">if cfg.DefaultLanguage == "" </span><span class="cov0" title="0">{
                cfg.DefaultLanguage = "ja-JP"
        }</span>
        <span class="cov0" title="0">if client == nil </span><span class="cov0" title="0">{
                client = &amp;http.Client{Timeout: 5 * time.Second}
        }</span>

        <span class="cov0" title="0">return &amp;movieService{
                db:         db,
                httpClient: client,
                cfg:        cfg,
        }</span>
}

// TMDB の /movie/{movie_id} レスポンスのうち、必要なフィールドのみを表す構造体。
type tmdbMovieResponse struct {
        ID            int      `json:"id"`
        Title         string   `json:"title"`
        OriginalTitle string   `json:"original_title"`
        PosterPath    *string  `json:"poster_path"`
        BackdropPath  *string  `json:"backdrop_path"`
        ReleaseDate   string   `json:"release_date"`
        VoteAverage   *float64 `json:"vote_average"`
        Overview      *string  `json:"overview"`
        Genres        []struct {
                ID   int    `json:"id"`
                Name string `json:"name"`
        } `json:"genres"`
        Runtime *int `json:"runtime"`
}

// TMDB の /search/movie の必要最小限のレスポンスを表す構造体。
type tmdbSearchResponse struct {
        Page         int `json:"page"`
        TotalPages   int `json:"total_pages"`
        TotalResults int `json:"total_results"`
        Results      []struct {
                ID            int      `json:"id"`
                Title         string   `json:"title"`
                OriginalTitle string   `json:"original_title"`
                PosterPath    *string  `json:"poster_path"`
                ReleaseDate   string   `json:"release_date"`
                VoteAverage   *float64 `json:"vote_average"`
        } `json:"results"`
}

// フロントに返す検索候補を表す構造体。
type TMDBSearchResult struct {
        TmdbMovieID   int      `json:"tmdb_movie_id"`
        Title         string   `json:"title"`
        OriginalTitle *string  `json:"original_title,omitempty"`
        PosterPath    *string  `json:"poster_path,omitempty"`
        ReleaseDate   *string  `json:"release_date,omitempty"`
        VoteAverage   *float64 `json:"vote_average,omitempty"`
}

// TMDB の検索APIで映画を検索し、候補一覧を返す。
func (s *movieService) SearchMovies(ctx context.Context, query string, page int) ([]TMDBSearchResult, int, error) <span class="cov0" title="0">{
        q := strings.TrimSpace(query)
        if q == "" </span><span class="cov0" title="0">{
                return []TMDBSearchResult{}, 0, nil
        }</span>
        <span class="cov0" title="0">if page &lt;= 0 </span><span class="cov0" title="0">{
                page = 1
        }</span>
        <span class="cov0" title="0">if s.cfg.APIKey == "" </span><span class="cov0" title="0">{
                return nil, 0, errors.New("TMDB_API_KEY is not set")
        }</span>

        <span class="cov0" title="0">base, err := url.Parse(s.cfg.BaseURL)
        if err != nil </span><span class="cov0" title="0">{
                return nil, 0, fmt.Errorf("invalid TMDB_BASE_URL: %w", err)
        }</span>
        <span class="cov0" title="0">base.Path = path.Join(base.Path, "search", "movie")

        params := base.Query()
        params.Set("query", q)
        params.Set("page", strconv.Itoa(page))
        if s.cfg.DefaultLanguage != "" </span><span class="cov0" title="0">{
                params.Set("language", s.cfg.DefaultLanguage)
        }</span>
        <span class="cov0" title="0">base.RawQuery = params.Encode()

        // リクエストを作成する。
        req, err := http.NewRequestWithContext(ctx, http.MethodGet, base.String(), nil)
        if err != nil </span><span class="cov0" title="0">{
                return nil, 0, fmt.Errorf("failed to create TMDB request: %w", err)
        }</span>

        <span class="cov0" title="0">token := strings.TrimSpace(s.cfg.APIKey)
        if token != "" </span><span class="cov0" title="0">{
                if strings.HasPrefix(strings.ToLower(token), "bearer ") </span><span class="cov0" title="0">{
                        req.Header.Set("Authorization", token)
                }</span> else<span class="cov0" title="0"> {
                        req.Header.Set("Authorization", "Bearer "+token)
                }</span>
        }
        <span class="cov0" title="0">req.Header.Set("Accept", "application/json")

        // TMDB にリクエストを送信。
        resp, err := s.httpClient.Do(req)
        if err != nil </span><span class="cov0" title="0">{
                return nil, 0, fmt.Errorf("failed to call TMDB: %w", err)
        }</span>
        <span class="cov0" title="0">defer resp.Body.Close()

        if resp.StatusCode &lt; 200 || resp.StatusCode &gt;= 300 </span><span class="cov0" title="0">{
                return nil, 0, fmt.Errorf("tmdb request failed: status=%d", resp.StatusCode)
        }</span>

        <span class="cov0" title="0">var body tmdbSearchResponse
        if err := json.NewDecoder(resp.Body).Decode(&amp;body); err != nil </span><span class="cov0" title="0">{
                return nil, 0, fmt.Errorf("failed to decode TMDB response: %w", err)
        }</span>

        // TMDBSearchResult に変換。
        <span class="cov0" title="0">out := make([]TMDBSearchResult, 0, len(body.Results))
        for _, r := range body.Results </span><span class="cov0" title="0">{
                var release *string
                if strings.TrimSpace(r.ReleaseDate) != "" </span><span class="cov0" title="0">{
                        s := strings.TrimSpace(r.ReleaseDate)
                        release = &amp;s
                }</span>
                <span class="cov0" title="0">var original *string
                if strings.TrimSpace(r.OriginalTitle) != "" </span><span class="cov0" title="0">{
                        s := strings.TrimSpace(r.OriginalTitle)
                        original = &amp;s
                }</span>
                <span class="cov0" title="0">out = append(out, TMDBSearchResult{
                        TmdbMovieID:   r.ID,
                        Title:         r.Title,
                        OriginalTitle: original,
                        PosterPath:    r.PosterPath,
                        ReleaseDate:   release,
                        VoteAverage:   r.VoteAverage,
                })</span>
        }

        <span class="cov0" title="0">return out, body.TotalResults, nil</span>
}

// 指定した TMDB 映画 ID に対応する movie_cache レコードの存在と有効期限を保証する。
// - 有効なキャッシュがあればそれを返す
// - キャッシュが無い、または期限切れの場合は TMDB から取得してキャッシュを更新する
func (s *movieService) EnsureMovieCache(ctx context.Context, tmdbMovieID int) (*model.MovieCache, error) <span class="cov0" title="0">{
        if tmdbMovieID &lt;= 0 </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("invalid tmdb movie id: %d", tmdbMovieID)
        }</span>
        <span class="cov0" title="0">if s.cfg.APIKey == "" </span><span class="cov0" title="0">{
                return nil, errors.New("TMDB_API_KEY is not set")
        }</span>

        <span class="cov0" title="0">now := time.Now()

        var cache model.MovieCache
        err := s.db.WithContext(ctx).
                Where("tmdb_movie_id = ?", tmdbMovieID).
                First(&amp;cache).
                Error

        switch </span>{
        case err == nil &amp;&amp; cache.ExpiresAt.After(now):<span class="cov0" title="0">
                // 有効なキャッシュがある場合はそのまま返す
                // デバッグログ（DEBUG）
                s.logger.Debug("service.EnsureMovieCache cache hit",
                        slog.Int("tmdb_movie_id", tmdbMovieID),
                )
                return &amp;cache, nil</span>
        case err != nil &amp;&amp; !errors.Is(err, gorm.ErrRecordNotFound):<span class="cov0" title="0">
                // それ以外の DB エラーはそのまま返す
                // エラーログ（ERROR）
                s.logger.Error("service.EnsureMovieCache failed",
                        slog.Int("tmdb_movie_id", tmdbMovieID),
                        slog.Any("error", err),
                )
                return nil, err</span>
        }

        // キャッシュが存在しない、または期限切れの場合は TMDB から取得する
        <span class="cov0" title="0">tmdbMovie, err := s.fetchMovieFromTMDB(ctx, tmdbMovieID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">cache, err = s.buildMovieCacheFromTMDB(tmdbMovie, now)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">if err := s.upsertMovieCache(ctx, &amp;cache); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">return &amp;cache, nil</span>
}

// TMDB の /movie/{movie_id} エンドポイントから映画情報を取得する。
func (s *movieService) fetchMovieFromTMDB(ctx context.Context, tmdbMovieID int) (*tmdbMovieResponse, error) <span class="cov0" title="0">{
        base, err := url.Parse(s.cfg.BaseURL)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("invalid TMDB_BASE_URL: %w", err)
        }</span>

        <span class="cov0" title="0">base.Path = path.Join(base.Path, "movie", strconv.Itoa(tmdbMovieID))

        q := base.Query()
        if s.cfg.DefaultLanguage != "" </span><span class="cov0" title="0">{
                q.Set("language", s.cfg.DefaultLanguage)
        }</span>
        <span class="cov0" title="0">base.RawQuery = q.Encode()

        req, err := http.NewRequestWithContext(ctx, http.MethodGet, base.String(), nil)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to create TMDB request: %w", err)
        }</span>
        // TMDB は v4 認証として Authorization: Bearer をサポートする。
        // このリポジトリでは TMDB_API_KEY を Bearer トークンとして送る前提にする（クエリには付けない）。
        <span class="cov0" title="0">token := strings.TrimSpace(s.cfg.APIKey)
        if token != "" </span><span class="cov0" title="0">{
                if strings.HasPrefix(strings.ToLower(token), "bearer ") </span><span class="cov0" title="0">{
                        req.Header.Set("Authorization", token)
                }</span> else<span class="cov0" title="0"> {
                        req.Header.Set("Authorization", "Bearer "+token)
                }</span>
        }
        <span class="cov0" title="0">req.Header.Set("Accept", "application/json")

        // デバッグログ（DEBUG）
        s.logger.Debug("service.fetchMovieFromTMDB request",
                slog.Int("tmdb_movie_id", tmdbMovieID),
                slog.String("url", base.String()),
        )

        resp, err := s.httpClient.Do(req)
        if err != nil </span><span class="cov0" title="0">{
                // エラーログ（ERROR）
                s.logger.Error("service.fetchMovieFromTMDB request failed",
                        slog.Int("tmdb_movie_id", tmdbMovieID),
                        slog.Any("error", err),
                )
                return nil, fmt.Errorf("failed to call TMDB: %w", err)
        }</span>
        <span class="cov0" title="0">defer resp.Body.Close()

        if resp.StatusCode == http.StatusNotFound </span><span class="cov0" title="0">{
                // デバッグログ（DEBUG）
                s.logger.Debug("service.fetchMovieFromTMDB not found",
                        slog.Int("tmdb_movie_id", tmdbMovieID),
                        slog.Int("status_code", resp.StatusCode),
                )
                return nil, fmt.Errorf("tmdb movie not found: %d", tmdbMovieID)
        }</span>
        <span class="cov0" title="0">if resp.StatusCode &lt; 200 || resp.StatusCode &gt;= 300 </span><span class="cov0" title="0">{
                // エラーログ（ERROR）
                s.logger.Error("service.fetchMovieFromTMDB request failed",
                        slog.Int("tmdb_movie_id", tmdbMovieID),
                        slog.Int("status_code", resp.StatusCode),
                )
                return nil, fmt.Errorf("tmdb request failed: status=%d", resp.StatusCode)
        }</span>

        <span class="cov0" title="0">var body tmdbMovieResponse
        if err := json.NewDecoder(resp.Body).Decode(&amp;body); err != nil </span><span class="cov0" title="0">{
                // エラーログ（ERROR）
                s.logger.Error("service.fetchMovieFromTMDB decode failed",
                        slog.Int("tmdb_movie_id", tmdbMovieID),
                        slog.Any("error", err),
                )
                return nil, fmt.Errorf("failed to decode TMDB response: %w", err)
        }</span>

        // デバッグログ（DEBUG）
        <span class="cov0" title="0">s.logger.Debug("service.fetchMovieFromTMDB success",
                slog.Int("tmdb_movie_id", tmdbMovieID),
                slog.String("title", body.Title),
        )
        return &amp;body, nil</span>
}

// TMDB レスポンスから movie_cache レコードを構築する。
func (s *movieService) buildMovieCacheFromTMDB(movie *tmdbMovieResponse, now time.Time) (model.MovieCache, error) <span class="cov0" title="0">{
        cache := model.MovieCache{
                TmdbMovieID: movie.ID,
                Title:       movie.Title,
                CachedAt:    now,
                ExpiresAt:   now.Add(7 * 24 * time.Hour),
        }

        if movie.OriginalTitle != "" </span><span class="cov0" title="0">{
                cache.OriginalTitle = &amp;movie.OriginalTitle
        }</span>
        <span class="cov0" title="0">cache.PosterPath = movie.PosterPath
        cache.BackdropPath = movie.BackdropPath

        if movie.ReleaseDate != "" </span><span class="cov0" title="0">{
                if t, err := time.Parse("2006-01-02", movie.ReleaseDate); err == nil </span><span class="cov0" title="0">{
                        cache.ReleaseDate = &amp;t
                }</span>
        }

        <span class="cov0" title="0">cache.VoteAverage = movie.VoteAverage
        cache.Overview = movie.Overview

        if len(movie.Genres) &gt; 0 </span><span class="cov0" title="0">{
                b, err := json.Marshal(movie.Genres)
                if err != nil </span><span class="cov0" title="0">{
                        return model.MovieCache{}, fmt.Errorf("failed to marshal genres: %w", err)
                }</span>
                <span class="cov0" title="0">cache.Genres = datatypes.JSON(b)</span>
        }

        <span class="cov0" title="0">cache.Runtime = movie.Runtime

        return cache, nil</span>
}

// movie_cache テーブルに対して UPSERT を行う。
func (s *movieService) upsertMovieCache(ctx context.Context, cache *model.MovieCache) error <span class="cov0" title="0">{
        return s.db.WithContext(ctx).Clauses(clause.OnConflict{
                Columns:   []clause.Column{{Name: "tmdb_movie_id"}},
                UpdateAll: true,
        }).Create(cache).Error
}</span>
</pre>
		
		<pre class="file" id="file29" style="display: none">package service

import (
        "context"
        "errors"
        "fmt"
        "log/slog"
        "strings"
        "time"

        "cinetag-backend/src/internal/model"
        "cinetag-backend/src/internal/repository"

        "gorm.io/gorm"
)

// 公開タグ一覧で返す1件分の情報を表す構造体。
type TagListItem struct {
        ID              string    `json:"id"`
        Title           string    `json:"title"`
        Description     *string   `json:"description,omitempty"`
        Author          string    `json:"author"`
        AuthorDisplayID string    `json:"author_display_id"`
        CoverImageURL   *string   `json:"cover_image_url,omitempty"`
        IsPublic        bool      `json:"is_public"`
        MovieCount      int       `json:"movie_count"`
        FollowerCount   int       `json:"follower_count"`
        Images          []string  `json:"images"`
        CreatedAt       time.Time `json:"created_at"`
}

// タグに関するユースケースを表すインターフェース。
type TagService interface {
        // 公開タグを検索・ソート・ページングして返す。
        ListPublicTags(ctx context.Context, q, sort string, page, pageSize int) ([]TagListItem, int64, error)

        // ユーザーIDに紐づくタグ一覧を返す。
        // publicOnly が true の場合、公開タグのみを返す（他ユーザーのページ閲覧時）。
        ListTagsByUserID(ctx context.Context, userID string, publicOnly bool, page, pageSize int) ([]TagListItem, int64, error)

        // 指定タグの詳細を返す。
        // - viewerUserID は任意で、非公開タグの参照権限判定に利用する。
        // - page はページ番号を指定する。
        // - pageSize はページサイズを指定する。
        GetTagDetail(ctx context.Context, tagID string, viewerUserID *string) (*TagDetail, error)

        // 指定タグに含まれる映画一覧を返す。
        // - viewerUserID は任意で、非公開タグの参照権限判定に利用する。
        // - page はページ番号を指定する。
        // - pageSize はページサイズを指定する。
        ListTagMovies(ctx context.Context, tagID string, viewerUserID *string, page, pageSize int) ([]TagMovieItem, int64, error)

        // 新しいタグを作成して返す。
        // - in は作成するタグの情報を指定する。
        CreateTag(ctx context.Context, in CreateTagInput) (*model.Tag, error)

        // タグに映画を追加して返す（作成者のみ）。
        // - in は追加する映画の情報を指定する。
        AddMovieToTag(ctx context.Context, in AddMovieToTagInput) (*model.TagMovie, error)

        // タグのメタ情報を更新して返す（作成者のみ）。
        // - patch は更新するフィールドとその新しい値を指定する。
        UpdateTag(ctx context.Context, tagID string, userID string, patch UpdateTagPatch) (*TagDetail, error)

        // タグから映画を削除する。
        // - タグ作成者は全ての映画を削除可能。
        // - 他のユーザーは自分が追加した映画のみ削除可能。
        RemoveMovieFromTag(ctx context.Context, tagMovieID string, userID string) error

        // タグをフォローする。
        // - tagID はフォローするタグのIDを指定する。
        // - userID はフォローするユーザーのIDを指定する。
        FollowTag(ctx context.Context, tagID, userID string) error

        // タグのフォローを解除する。
        // - tagID はフォローを解除するタグのIDを指定する。
        // - userID はフォローを解除するユーザーのIDを指定する。
        UnfollowTag(ctx context.Context, tagID, userID string) error

        // ユーザーがタグをフォローしているかチェックする。
        // - tagID はチェックするタグのIDを指定する。
        // - userID はチェックするユーザーのIDを指定する。
        IsFollowingTag(ctx context.Context, tagID, userID string) (bool, error)

        // タグのフォロワー一覧を返す。
        // - tagID はフォロワーを取得するタグのIDを指定する。
        // - page はページ番号を指定する。
        // - pageSize はページサイズを指定する。
        ListTagFollowers(ctx context.Context, tagID string, page, pageSize int) ([]*model.User, int64, error)

        // ユーザーがフォローしているタグ一覧を返す。
        // - userID はフォローしているタグを取得するユーザーのIDを指定する。
        // - page はページ番号を指定する。
        // - pageSize はページサイズを指定する。
        ListFollowingTags(ctx context.Context, userID string, page, pageSize int) ([]TagListItem, int64, error)
}

type tagService struct {
        logger          *slog.Logger
        tagRepo         repository.TagRepository
        tagMovieRepo    repository.TagMovieRepository
        tagFollowerRepo repository.TagFollowerRepository
        movieService    MovieService
        imageBaseURL    string
}

// TagService を生成する。
func NewTagService(
        logger *slog.Logger,
        tagRepo repository.TagRepository,
        tagMovieRepo repository.TagMovieRepository,
        tagFollowerRepo repository.TagFollowerRepository,
        movieService MovieService,
        imageBaseURL string,
) TagService <span class="cov8" title="1">{
        return &amp;tagService{
                logger:          logger,
                tagRepo:         tagRepo,
                tagMovieRepo:    tagMovieRepo,
                tagFollowerRepo: tagFollowerRepo,
                movieService:    movieService,
                imageBaseURL:    strings.TrimRight(imageBaseURL, "/"),
        }
}</span>

// タグ作成時の入力値を表す構造体。
type CreateTagInput struct {
        UserID         string
        Title          string
        Description    *string
        CoverImageURL  *string
        IsPublic       *bool
        AddMoviePolicy *string
}

// タグへ映画を追加する際の入力値を表す構造体。
type AddMovieToTagInput struct {
        TagID       string
        UserID      string
        TmdbMovieID int
        Note        *string
        Position    int
}

// タグ詳細API向けのレスポンスモデルを表す構造体。
// - フロントの zod schema が owner を許容しているため、owner を返す形に寄せる。
type TagDetail struct {
        ID             string    `json:"id"`
        Title          string    `json:"title"`
        Description    *string   `json:"description,omitempty"`
        CoverImageURL  *string   `json:"cover_image_url,omitempty"`
        IsPublic       bool      `json:"is_public"`
        AddMoviePolicy string    `json:"add_movie_policy"`
        MovieCount     int       `json:"movie_count"`
        FollowerCount  int       `json:"follower_count"`
        Owner          TagOwner  `json:"owner"`
        CanEdit        bool      `json:"can_edit"`
        CanAddMovie    bool      `json:"can_add_movie"`
        CreatedAt      time.Time `json:"created_at"`
        UpdatedAt      time.Time `json:"updated_at"`

        // UI都合（既存画面の参加者表示）: 現時点では follower_count を参加者数として扱う。
        // 一覧は未実装のため空配列を返す。
        ParticipantCount int              `json:"participant_count"`
        Participants     []TagParticipant `json:"participants"`
}

// タグの所有者を表す構造体。
type TagOwner struct {
        ID          string  `json:"id"`
        DisplayID   string  `json:"display_id"`
        DisplayName string  `json:"display_name"`
        AvatarURL   *string `json:"avatar_url,omitempty"`
}

// タグの参加者を表す構造体。
type TagParticipant struct {
        Name      string  `json:"name"`
        DisplayID string  `json:"display_id,omitempty"`
        AvatarURL *string `json:"avatar_url,omitempty"`
}

// タグ内映画一覧API向けのレスポンスモデルを表す構造体。
type TagMovieItem struct {
        ID            string    `json:"id"`
        TagID         string    `json:"tag_id"`
        TmdbMovieID   int       `json:"tmdb_movie_id"`
        Note          *string   `json:"note,omitempty"`
        Position      int       `json:"position"`
        AddedByUserID string    `json:"added_by_user_id"`
        CanDelete     bool      `json:"can_delete"`
        CreatedAt     time.Time `json:"created_at"`
        Movie         *MovieRef `json:"movie,omitempty"`
}

// 映画を表す構造体。
type MovieRef struct {
        Title         string   `json:"title"`
        OriginalTitle *string  `json:"original_title,omitempty"`
        PosterPath    *string  `json:"poster_path,omitempty"`
        ReleaseDate   *string  `json:"release_date,omitempty"`
        VoteAverage   *float64 `json:"vote_average,omitempty"`
}

// タグ更新の入力値を表す構造体（部分更新）。
// nil のフィールドは更新しません。
type UpdateTagPatch struct {
        Title          *string
        Description    **string
        CoverImageURL  **string
        IsPublic       *bool
        AddMoviePolicy *string
}

// エラー定数。
var (
        ErrTagNotFound           = errors.New("tag not found")            // タグが存在しない
        ErrTagPermissionDenied   = errors.New("tag permission denied")    // タグの編集権限がない
        ErrTagMovieAlreadyExists = errors.New("tag movie already exists") // タグに既に映画が存在する
        ErrTagMovieNotFound      = errors.New("tag movie not found")      // タグ映画が存在しない
        ErrAlreadyFollowingTag   = errors.New("already following tag")    // 既にタグをフォロー済み
        ErrNotFollowingTag       = errors.New("not following tag")        // タグをフォローしていない
)

// タグを更新する。
func (s *tagService) UpdateTag(ctx context.Context, tagID string, userID string, patch UpdateTagPatch) (*TagDetail, error) <span class="cov8" title="1">{

        // 必須バリデーション（tagID/userID）をチェックする。
        if strings.TrimSpace(tagID) == "" </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("tag_id is required")
        }</span>
        <span class="cov8" title="1">if strings.TrimSpace(userID) == "" </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("user_id is required")
        }</span>

        // タグの存在確認
        <span class="cov8" title="1">tag, err := s.tagRepo.FindByID(ctx, tagID)
        if err != nil </span><span class="cov0" title="0">{
                if errors.Is(err, gorm.ErrRecordNotFound) </span><span class="cov0" title="0">{
                        return nil, ErrTagNotFound
                }</span>
                // タグの取得に失敗した場合、エラーを返す
                <span class="cov0" title="0">return nil, err</span>
        }
        // タグの作成者がユーザーIDと一致しない場合、エラーを返す
        <span class="cov8" title="1">if tag.UserID != userID </span><span class="cov0" title="0">{
                return nil, ErrTagPermissionDenied
        }</span>

        // バリデーション（title/description）
        <span class="cov8" title="1">if patch.Title != nil </span><span class="cov0" title="0">{
                if l := len([]rune(strings.TrimSpace(*patch.Title))); l == 0 || l &gt; 100 </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("title must be between 1 and 100 characters")
                }</span>
        }
        <span class="cov8" title="1">if patch.Description != nil &amp;&amp; *patch.Description != nil </span><span class="cov0" title="0">{
                if l := len([]rune(**patch.Description)); l &gt; 500 </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("description must be 500 characters or less")
                }</span>
        }

        // add_movie_policy のバリデーション
        <span class="cov8" title="1">if patch.AddMoviePolicy != nil </span><span class="cov8" title="1">{
                if *patch.AddMoviePolicy != "everyone" &amp;&amp; *patch.AddMoviePolicy != "owner_only" </span><span class="cov8" title="1">{
                        return nil, fmt.Errorf("add_movie_policy must be 'everyone' or 'owner_only'")
                }</span>
        }

        // タグを更新する。
        <span class="cov8" title="1">err = s.tagRepo.UpdateByID(ctx, tagID, repository.TagUpdatePatch{
                Title:          patch.Title,
                Description:    patch.Description,
                CoverImageURL:  patch.CoverImageURL,
                IsPublic:       patch.IsPublic,
                AddMoviePolicy: patch.AddMoviePolicy,
        })
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // 更新後の詳細を返す（owner のため viewerUserID を userID にする）
        <span class="cov8" title="1">viewer := userID
        return s.GetTagDetail(ctx, tagID, &amp;viewer)</span>
}

// 指定タグの詳細を返す。
// - viewerUserID は任意で、非公開タグの参照権限判定に利用する。
func (s *tagService) GetTagDetail(ctx context.Context, tagID string, viewerUserID *string) (*TagDetail, error) <span class="cov8" title="1">{
        // 必須バリデーション
        if strings.TrimSpace(tagID) == "" </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("tag_id is required")
        }</span>

        // タグの詳細を取得。
        <span class="cov8" title="1">row, err := s.tagRepo.FindDetailByID(ctx, tagID)
        if err != nil </span><span class="cov0" title="0">{
                if errors.Is(err, gorm.ErrRecordNotFound) </span><span class="cov0" title="0">{
                        return nil, ErrTagNotFound
                }</span>
                <span class="cov0" title="0">return nil, err</span>
        }

        // 非公開タグの場合、ビューアーの権限をチェック。
        <span class="cov8" title="1">if !row.IsPublic </span><span class="cov0" title="0">{
                if viewerUserID == nil || strings.TrimSpace(*viewerUserID) == "" || *viewerUserID != row.OwnerID </span><span class="cov0" title="0">{
                        // ビューアーの権限がない場合、エラーを返す
                        return nil, ErrTagPermissionDenied
                }</span>
        }

        // ビューアーがタグの作成者の場合、編集可能なフラグを立てる
        <span class="cov8" title="1">canEdit := viewerUserID != nil &amp;&amp; strings.TrimSpace(*viewerUserID) != "" &amp;&amp; *viewerUserID == row.OwnerID

        // 映画追加権限の判定
        canAddMovie := false
        if viewerUserID != nil &amp;&amp; strings.TrimSpace(*viewerUserID) != "" </span><span class="cov8" title="1">{
                if row.AddMoviePolicy == "everyone" </span><span class="cov8" title="1">{
                        canAddMovie = true
                }</span> else<span class="cov8" title="1"> if row.AddMoviePolicy == "owner_only" </span><span class="cov8" title="1">{
                        canAddMovie = *viewerUserID == row.OwnerID
                }</span>
        }

        // 参加者（タグに映画を追加したユーザー、作成者除く）を取得
        <span class="cov8" title="1">contributors, contributorCount, err := s.tagMovieRepo.ListContributorsByTag(ctx, tagID, row.OwnerID, 10)
        if err != nil </span><span class="cov0" title="0">{
                // 参加者取得に失敗しても詳細自体は返す
                contributors = []repository.TagContributor{}
                contributorCount = 0
        }</span>
        <span class="cov8" title="1">participants := make([]TagParticipant, 0, len(contributors))
        for _, c := range contributors </span><span class="cov0" title="0">{
                participants = append(participants, TagParticipant{
                        Name:      c.DisplayName,
                        DisplayID: c.DisplayID,
                        AvatarURL: c.AvatarURL,
                })
        }</span>

        // タグの詳細を返す。
        <span class="cov8" title="1">return &amp;TagDetail{
                ID:             row.ID,
                Title:          row.Title,
                Description:    row.Description,
                CoverImageURL:  row.CoverImageURL,
                IsPublic:       row.IsPublic,
                AddMoviePolicy: row.AddMoviePolicy,
                MovieCount:     row.MovieCount,
                FollowerCount:  row.FollowerCount,
                Owner: TagOwner{
                        ID:          row.OwnerID,
                        DisplayID:   row.OwnerDisplayID,
                        DisplayName: row.OwnerDisplayName,
                        AvatarURL:   row.OwnerAvatarURL,
                },
                CanEdit:          canEdit,
                CanAddMovie:      canAddMovie,
                CreatedAt:        row.CreatedAt,
                UpdatedAt:        row.UpdatedAt,
                ParticipantCount: int(contributorCount),
                Participants:     participants,
        }, nil</span>
}

// 指定タグに含まれる映画一覧を返す。
func (s *tagService) ListTagMovies(ctx context.Context, tagID string, viewerUserID *string, page, pageSize int) ([]TagMovieItem, int64, error) <span class="cov8" title="1">{
        if strings.TrimSpace(tagID) == "" </span><span class="cov0" title="0">{
                return nil, 0, fmt.Errorf("tag_id is required")
        }</span>
        <span class="cov8" title="1">if page &lt; 1 </span><span class="cov0" title="0">{
                page = 1
        }</span>
        <span class="cov8" title="1">if pageSize &lt;= 0 </span><span class="cov0" title="0">{
                pageSize = 50
        }</span>
        <span class="cov8" title="1">if pageSize &gt; 100 </span><span class="cov0" title="0">{
                pageSize = 100
        }</span>

        <span class="cov8" title="1">tag, err := s.tagRepo.FindByID(ctx, tagID)
        if err != nil </span><span class="cov0" title="0">{
                if errors.Is(err, gorm.ErrRecordNotFound) </span><span class="cov0" title="0">{
                        return nil, 0, ErrTagNotFound
                }</span>
                <span class="cov0" title="0">return nil, 0, err</span>
        }

        // 非公開タグの場合、ビューアーの権限をチェックする。
        <span class="cov8" title="1">if !tag.IsPublic </span><span class="cov0" title="0">{
                if viewerUserID == nil || strings.TrimSpace(*viewerUserID) == "" || *viewerUserID != tag.UserID </span><span class="cov0" title="0">{
                        return nil, 0, ErrTagPermissionDenied
                }</span>
        }

        <span class="cov8" title="1">viewerID := ""
        if viewerUserID != nil </span><span class="cov8" title="1">{
                viewerID = strings.TrimSpace(*viewerUserID)
        }</span>
        <span class="cov8" title="1">viewerIsOwner := viewerID != "" &amp;&amp; viewerID == tag.UserID

        offset := (page - 1) * pageSize
        rows, total, err := s.tagMovieRepo.ListByTag(ctx, tagID, offset, pageSize)
        if err != nil </span><span class="cov0" title="0">{
                return nil, 0, err
        }</span>
        <span class="cov8" title="1">if total == 0 </span><span class="cov0" title="0">{
                return []TagMovieItem{}, 0, nil
        }</span>

        <span class="cov8" title="1">items := make([]TagMovieItem, 0, len(rows))
        for _, r := range rows </span><span class="cov8" title="1">{
                var movie *MovieRef

                // movie_cache が join できている場合はそれを使う
                if r.MovieTitle != nil &amp;&amp; strings.TrimSpace(*r.MovieTitle) != "" </span><span class="cov0" title="0">{
                        title := strings.TrimSpace(*r.MovieTitle)
                        var release *string
                        if r.MovieReleaseDate != nil </span><span class="cov0" title="0">{
                                s := r.MovieReleaseDate.Format("2006-01-02")
                                release = &amp;s
                        }</span>
                        <span class="cov0" title="0">movie = &amp;MovieRef{
                                Title:         title,
                                OriginalTitle: r.MovieOriginalTitle,
                                PosterPath:    r.MoviePosterPath,
                                ReleaseDate:   release,
                                VoteAverage:   r.MovieVoteAverage,
                        }</span>
                } else<span class="cov8" title="1"> if s.movieService != nil </span><span class="cov0" title="0">{
                        // ベストエフォートでキャッシュを取得して埋める
                        cache, err := s.movieService.EnsureMovieCache(ctx, r.TmdbMovieID)
                        if err == nil &amp;&amp; cache != nil </span><span class="cov0" title="0">{
                                var release *string
                                if cache.ReleaseDate != nil </span><span class="cov0" title="0">{
                                        s := cache.ReleaseDate.Format("2006-01-02")
                                        release = &amp;s
                                }</span>
                                <span class="cov0" title="0">movie = &amp;MovieRef{
                                        Title:         cache.Title,
                                        OriginalTitle: cache.OriginalTitle,
                                        PosterPath:    cache.PosterPath,
                                        ReleaseDate:   release,
                                        VoteAverage:   cache.VoteAverage,
                                }</span>
                        }
                }

                // can_delete はバックエンドの削除権限ルールに従って判定する。
                // - 未認証: false
                // - タグ作成者: true（全て削除可能）
                // - owner_only タグ: 作成者以外は false
                // - それ以外: 自分が追加した映画のみ true
                <span class="cov8" title="1">canDelete := false
                if viewerID != "" </span><span class="cov8" title="1">{
                        if viewerIsOwner </span><span class="cov8" title="1">{
                                canDelete = true
                        }</span> else<span class="cov8" title="1"> if tag.AddMoviePolicy == "owner_only" </span><span class="cov8" title="1">{
                                canDelete = false
                        }</span> else<span class="cov8" title="1"> {
                                canDelete = r.AddedByUser == viewerID
                        }</span>
                }

                <span class="cov8" title="1">items = append(items, TagMovieItem{
                        ID:            r.ID,
                        TagID:         r.TagID,
                        TmdbMovieID:   r.TmdbMovieID,
                        Note:          r.Note,
                        Position:      r.Position,
                        AddedByUserID: r.AddedByUser,
                        CanDelete:     canDelete,
                        CreatedAt:     r.CreatedAt,
                        Movie:         movie,
                })</span>
        }

        <span class="cov8" title="1">return items, total, nil</span>
}

// CreateTag は新しいタグを作成します。
func (s *tagService) CreateTag(ctx context.Context, in CreateTagInput) (*model.Tag, error) <span class="cov8" title="1">{
        isPublic := true
        if in.IsPublic != nil </span><span class="cov8" title="1">{
                isPublic = *in.IsPublic
        }</span>

        // デフォルトは "everyone"（全ユーザーが映画追加可能）
        <span class="cov8" title="1">addMoviePolicy := "everyone"
        if in.AddMoviePolicy != nil &amp;&amp; (*in.AddMoviePolicy == "everyone" || *in.AddMoviePolicy == "owner_only") </span><span class="cov8" title="1">{
                addMoviePolicy = *in.AddMoviePolicy
        }</span>

        <span class="cov8" title="1">tag := model.Tag{
                UserID:         in.UserID,
                Title:          in.Title,
                Description:    in.Description,
                CoverImageURL:  in.CoverImageURL,
                IsPublic:       isPublic,
                AddMoviePolicy: addMoviePolicy,
        }

        if err := s.tagRepo.Create(ctx, &amp;tag); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">return &amp;tag, nil</span>
}

// AddMovieToTag はタグに映画を追加します。
func (s *tagService) AddMovieToTag(ctx context.Context, in AddMovieToTagInput) (*model.TagMovie, error) <span class="cov8" title="1">{

        // バリデーション
        if in.TagID == "" </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("tag_id is required")
        }</span>
        <span class="cov8" title="1">if in.UserID == "" </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("user_id is required")
        }</span>
        <span class="cov8" title="1">if in.TmdbMovieID &lt;= 0 </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("invalid tmdb_movie_id: %d", in.TmdbMovieID)
        }</span>
        <span class="cov8" title="1">if in.Position &lt; 0 </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("position must be 0 or greater")
        }</span>

        // タグの存在確認と権限チェック
        <span class="cov8" title="1">tag, err := s.tagRepo.FindByID(ctx, in.TagID)
        if err != nil </span><span class="cov8" title="1">{
                if errors.Is(err, gorm.ErrRecordNotFound) </span><span class="cov8" title="1">{
                        return nil, ErrTagNotFound
                }</span>
                <span class="cov8" title="1">return nil, err</span>
        }

        // add_movie_policy に基づいて映画追加権限をチェック
        <span class="cov8" title="1">if tag.AddMoviePolicy == "owner_only" &amp;&amp; tag.UserID != in.UserID </span><span class="cov8" title="1">{
                return nil, ErrTagPermissionDenied
        }</span>

        // タグ映画を作成する。
        <span class="cov8" title="1">tm := model.TagMovie{
                TagID:       in.TagID,
                TmdbMovieID: in.TmdbMovieID,
                AddedByUser: in.UserID,
                Note:        in.Note,
                Position:    in.Position,
        }

        // タグ映画を作成する。
        if err := s.tagMovieRepo.Create(ctx, &amp;tm); err != nil </span><span class="cov8" title="1">{
                if errors.Is(err, repository.ErrTagMovieAlreadyExists) </span><span class="cov8" title="1">{
                        return nil, ErrTagMovieAlreadyExists
                }</span>
                <span class="cov8" title="1">return nil, err</span>
        }

        // タグの movie_count を加算（一覧の表示用）
        <span class="cov8" title="1">if err := s.tagRepo.IncrementMovieCount(ctx, in.TagID, 1); err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>

        // 可能であれば、作成時にベストエフォートでキャッシュを温める（失敗してもAPIは成功扱い）
        <span class="cov8" title="1">if s.movieService != nil </span><span class="cov0" title="0">{
                logger := s.logger // goroutine内で使用するためキャプチャ
                go func(movieID int) </span><span class="cov0" title="0">{
                        ctx2, cancel := context.WithTimeout(context.Background(), 5*time.Second)
                        defer cancel()
                        if _, err := s.movieService.EnsureMovieCache(ctx2, movieID); err != nil </span><span class="cov0" title="0">{
                                // エラーログ（ERROR）
                                logger.Error("service.CreateTag failed to warm movie cache",
                                        slog.Int("tmdb_movie_id", movieID),
                                        slog.Any("error", err),
                                )
                        }</span>
                }(in.TmdbMovieID)
        }

        <span class="cov8" title="1">return &amp;tm, nil</span>
}

// 公開タグ一覧を返す。
func (s *tagService) ListPublicTags(ctx context.Context, q, sort string, page, pageSize int) ([]TagListItem, int64, error) <span class="cov8" title="1">{
        if page &lt; 1 </span><span class="cov8" title="1">{
                page = 1
        }</span>
        <span class="cov8" title="1">if pageSize &lt;= 0 </span><span class="cov8" title="1">{
                pageSize = 20
        }</span>
        <span class="cov8" title="1">if pageSize &gt; 100 </span><span class="cov8" title="1">{
                pageSize = 100
        }</span>

        // 検索条件
        <span class="cov8" title="1">query := strings.TrimSpace(q)
        offset := (page - 1) * pageSize

        rows, total, err := s.tagRepo.ListPublicTags(ctx, repository.TagListFilter{
                Query:  query,
                Sort:   sort,
                Offset: offset,
                Limit:  pageSize,
        })
        if err != nil </span><span class="cov0" title="0">{
                return nil, 0, err
        }</span>
        <span class="cov8" title="1">if total == 0 </span><span class="cov8" title="1">{
                return []TagListItem{}, 0, nil
        }</span>

        // 映画ポスター画像の取得
        <span class="cov8" title="1">imagesByTag := make(map[string][]string, len(rows))
        if s.movieService != nil </span><span class="cov0" title="0">{
                for _, r := range rows </span><span class="cov0" title="0">{
                        // 各タグごとに、最新の追加順で最大 4 件の映画を取得
                        tagMovies, err := s.tagMovieRepo.ListRecentByTag(ctx, r.ID, 4)
                        if err != nil </span><span class="cov0" title="0">{
                                return nil, 0, err
                        }</span>

                        // デバッグログ（DEBUG）
                        <span class="cov0" title="0">s.logger.Debug("service.ListPublicTags processing tag movies",
                                slog.String("tag_id", r.ID),
                                slog.Int("tag_movies_count", len(tagMovies)),
                        )

                        for _, tm := range tagMovies </span><span class="cov0" title="0">{
                                if len(imagesByTag[r.ID]) &gt;= 4 </span><span class="cov0" title="0">{
                                        break</span>
                                }

                                // デバッグログ（DEBUG）
                                <span class="cov0" title="0">s.logger.Debug("service.ListPublicTags processing tag movie",
                                        slog.String("tag_id", r.ID),
                                        slog.Int("tmdb_movie_id", tm.TmdbMovieID),
                                )
                                cache, err := s.movieService.EnsureMovieCache(ctx, tm.TmdbMovieID)
                                if err != nil </span><span class="cov0" title="0">{
                                        // 画像の取得失敗はタグ一覧全体のエラーにはせずスキップする。
                                        continue</span>
                                }
                                <span class="cov0" title="0">if cache.PosterPath == nil || *cache.PosterPath == "" </span><span class="cov0" title="0">{
                                        continue</span>
                                }
                                <span class="cov0" title="0">poster := *cache.PosterPath
                                if s.imageBaseURL != "" </span><span class="cov0" title="0">{
                                        poster = s.imageBaseURL + poster
                                }</span>
                                <span class="cov0" title="0">imagesByTag[r.ID] = append(imagesByTag[r.ID], poster)</span>
                        }
                }
        }

        // 最終的なレスポンス構築
        <span class="cov8" title="1">items := make([]TagListItem, 0, len(rows))
        for _, r := range rows </span><span class="cov8" title="1">{
                item := TagListItem{
                        ID:              r.ID,
                        Title:           r.Title,
                        Description:     r.Description,
                        Author:          r.Author,
                        AuthorDisplayID: r.AuthorDisplayID,
                        CoverImageURL:   r.CoverImageURL,
                        IsPublic:        r.IsPublic,
                        MovieCount:      r.MovieCount,
                        FollowerCount:   r.FollowerCount,
                        Images:          imagesByTag[r.ID],
                        CreatedAt:       r.CreatedAt,
                }
                items = append(items, item)
        }</span>

        <span class="cov8" title="1">return items, total, nil</span>
}

// ユーザーIDに紐づくタグ一覧を返す。
func (s *tagService) ListTagsByUserID(ctx context.Context, userID string, publicOnly bool, page, pageSize int) ([]TagListItem, int64, error) <span class="cov0" title="0">{
        if strings.TrimSpace(userID) == "" </span><span class="cov0" title="0">{
                return nil, 0, fmt.Errorf("user_id is required")
        }</span>
        <span class="cov0" title="0">if page &lt; 1 </span><span class="cov0" title="0">{
                page = 1
        }</span>
        <span class="cov0" title="0">if pageSize &lt;= 0 </span><span class="cov0" title="0">{
                pageSize = 20
        }</span>
        <span class="cov0" title="0">if pageSize &gt; 100 </span><span class="cov0" title="0">{
                pageSize = 100
        }</span>

        <span class="cov0" title="0">offset := (page - 1) * pageSize

        rows, total, err := s.tagRepo.ListTagsByUserID(ctx, repository.UserTagListFilter{
                UserID:        userID,
                IncludePublic: publicOnly,
                Offset:        offset,
                Limit:         pageSize,
        })
        if err != nil </span><span class="cov0" title="0">{
                return nil, 0, err
        }</span>
        <span class="cov0" title="0">if total == 0 </span><span class="cov0" title="0">{
                return []TagListItem{}, 0, nil
        }</span>

        // 映画ポスター画像の取得
        <span class="cov0" title="0">imagesByTag := make(map[string][]string, len(rows))
        if s.movieService != nil </span><span class="cov0" title="0">{
                for _, r := range rows </span><span class="cov0" title="0">{
                        tagMovies, err := s.tagMovieRepo.ListRecentByTag(ctx, r.ID, 4)
                        if err != nil </span><span class="cov0" title="0">{
                                return nil, 0, err
                        }</span>

                        <span class="cov0" title="0">for _, tm := range tagMovies </span><span class="cov0" title="0">{
                                if len(imagesByTag[r.ID]) &gt;= 4 </span><span class="cov0" title="0">{
                                        break</span>
                                }
                                <span class="cov0" title="0">cache, err := s.movieService.EnsureMovieCache(ctx, tm.TmdbMovieID)
                                if err != nil </span><span class="cov0" title="0">{
                                        continue</span>
                                }
                                <span class="cov0" title="0">if cache.PosterPath == nil || *cache.PosterPath == "" </span><span class="cov0" title="0">{
                                        continue</span>
                                }
                                <span class="cov0" title="0">poster := *cache.PosterPath
                                if s.imageBaseURL != "" </span><span class="cov0" title="0">{
                                        poster = s.imageBaseURL + poster
                                }</span>
                                <span class="cov0" title="0">imagesByTag[r.ID] = append(imagesByTag[r.ID], poster)</span>
                        }
                }
        }

        <span class="cov0" title="0">items := make([]TagListItem, 0, len(rows))
        for _, r := range rows </span><span class="cov0" title="0">{
                item := TagListItem{
                        ID:              r.ID,
                        Title:           r.Title,
                        Description:     r.Description,
                        Author:          r.Author,
                        AuthorDisplayID: r.AuthorDisplayID,
                        CoverImageURL:   r.CoverImageURL,
                        IsPublic:        r.IsPublic,
                        MovieCount:      r.MovieCount,
                        FollowerCount:   r.FollowerCount,
                        Images:          imagesByTag[r.ID],
                        CreatedAt:       r.CreatedAt,
                }
                items = append(items, item)
        }</span>

        <span class="cov0" title="0">return items, total, nil</span>
}

// タグから映画を削除する。
// - タグ作成者は全ての映画を削除可能。
// - タグがowner_onlyの場合は作成者のみ削除可能。
// - それ以外の場合は、自分が追加した映画のみ削除可能。
func (s *tagService) RemoveMovieFromTag(ctx context.Context, tagMovieID string, userID string) error <span class="cov8" title="1">{
        if strings.TrimSpace(tagMovieID) == "" </span><span class="cov8" title="1">{
                return fmt.Errorf("tag_movie_id is required")
        }</span>
        <span class="cov8" title="1">if strings.TrimSpace(userID) == "" </span><span class="cov8" title="1">{
                return fmt.Errorf("user_id is required")
        }</span>

        // タグ映画を取得
        <span class="cov8" title="1">tagMovie, err := s.tagMovieRepo.FindByID(ctx, tagMovieID)
        if err != nil </span><span class="cov8" title="1">{
                if errors.Is(err, gorm.ErrRecordNotFound) </span><span class="cov8" title="1">{
                        return ErrTagMovieNotFound
                }</span>
                <span class="cov8" title="1">return err</span>
        }

        // タグを取得して権限チェック
        <span class="cov8" title="1">tag, err := s.tagRepo.FindByID(ctx, tagMovie.TagID)
        if err != nil </span><span class="cov8" title="1">{
                if errors.Is(err, gorm.ErrRecordNotFound) </span><span class="cov8" title="1">{
                        return ErrTagNotFound
                }</span>
                <span class="cov0" title="0">return err</span>
        }

        // 権限チェック
        // 1. タグがowner_onlyの場合、作成者のみ削除可能
        <span class="cov8" title="1">if tag.AddMoviePolicy == "owner_only" &amp;&amp; tag.UserID != userID </span><span class="cov8" title="1">{
                return ErrTagPermissionDenied
        }</span>

        // 2. タグ作成者は全ての映画を削除可能
        // 3. それ以外のユーザーは自分が追加した映画のみ削除可能
        <span class="cov8" title="1">if tag.UserID != userID &amp;&amp; tagMovie.AddedByUser != userID </span><span class="cov8" title="1">{
                return ErrTagPermissionDenied
        }</span>

        // 映画を削除
        <span class="cov8" title="1">if err := s.tagMovieRepo.Delete(ctx, tagMovieID); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // タグの movie_count を減算
        <span class="cov8" title="1">if err := s.tagRepo.IncrementMovieCount(ctx, tag.ID, -1); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">return nil</span>
}

// タグをフォローする。
func (s *tagService) FollowTag(ctx context.Context, tagID, userID string) error <span class="cov0" title="0">{
        if strings.TrimSpace(tagID) == "" </span><span class="cov0" title="0">{
                return fmt.Errorf("tag_id is required")
        }</span>
        <span class="cov0" title="0">if strings.TrimSpace(userID) == "" </span><span class="cov0" title="0">{
                return fmt.Errorf("user_id is required")
        }</span>

        // タグの存在確認
        <span class="cov0" title="0">tag, err := s.tagRepo.FindByID(ctx, tagID)
        if err != nil </span><span class="cov0" title="0">{
                if errors.Is(err, gorm.ErrRecordNotFound) </span><span class="cov0" title="0">{
                        return ErrTagNotFound
                }</span>
                <span class="cov0" title="0">return err</span>
        }

        // 非公開タグはフォローできない（作成者以外）
        <span class="cov0" title="0">if !tag.IsPublic &amp;&amp; tag.UserID != userID </span><span class="cov0" title="0">{
                return ErrTagPermissionDenied
        }</span>

        // 既にフォロー済みかチェック
        <span class="cov0" title="0">isFollowing, err := s.tagFollowerRepo.IsFollowing(ctx, tagID, userID)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">if isFollowing </span><span class="cov0" title="0">{
                return ErrAlreadyFollowingTag
        }</span>

        // フォロー関係を作成
        <span class="cov0" title="0">return s.tagFollowerRepo.Create(ctx, tagID, userID)</span>
}

// UnfollowTag はタグのフォローを解除します。
func (s *tagService) UnfollowTag(ctx context.Context, tagID, userID string) error <span class="cov0" title="0">{
        if strings.TrimSpace(tagID) == "" </span><span class="cov0" title="0">{
                return fmt.Errorf("tag_id is required")
        }</span>
        <span class="cov0" title="0">if strings.TrimSpace(userID) == "" </span><span class="cov0" title="0">{
                return fmt.Errorf("user_id is required")
        }</span>

        // タグの存在確認
        <span class="cov0" title="0">_, err := s.tagRepo.FindByID(ctx, tagID)
        if err != nil </span><span class="cov0" title="0">{
                if errors.Is(err, gorm.ErrRecordNotFound) </span><span class="cov0" title="0">{
                        return ErrTagNotFound
                }</span>
                <span class="cov0" title="0">return err</span>
        }

        // フォローしているかチェック
        <span class="cov0" title="0">isFollowing, err := s.tagFollowerRepo.IsFollowing(ctx, tagID, userID)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">if !isFollowing </span><span class="cov0" title="0">{
                return ErrNotFollowingTag
        }</span>

        // フォロー関係を削除
        <span class="cov0" title="0">return s.tagFollowerRepo.Delete(ctx, tagID, userID)</span>
}

// IsFollowingTag はユーザーがタグをフォローしているかチェックします。
func (s *tagService) IsFollowingTag(ctx context.Context, tagID, userID string) (bool, error) <span class="cov0" title="0">{
        if strings.TrimSpace(tagID) == "" </span><span class="cov0" title="0">{
                return false, fmt.Errorf("tag_id is required")
        }</span>
        <span class="cov0" title="0">if strings.TrimSpace(userID) == "" </span><span class="cov0" title="0">{
                return false, nil
        }</span>

        <span class="cov0" title="0">return s.tagFollowerRepo.IsFollowing(ctx, tagID, userID)</span>
}

// タグのフォロワー一覧を返す。
func (s *tagService) ListTagFollowers(ctx context.Context, tagID string, page, pageSize int) ([]*model.User, int64, error) <span class="cov0" title="0">{
        if strings.TrimSpace(tagID) == "" </span><span class="cov0" title="0">{
                return nil, 0, fmt.Errorf("tag_id is required")
        }</span>
        <span class="cov0" title="0">if page &lt; 1 </span><span class="cov0" title="0">{
                page = 1
        }</span>
        <span class="cov0" title="0">if pageSize &lt;= 0 </span><span class="cov0" title="0">{
                pageSize = 20
        }</span>
        <span class="cov0" title="0">if pageSize &gt; 100 </span><span class="cov0" title="0">{
                pageSize = 100
        }</span>

        // タグの存在確認
        <span class="cov0" title="0">_, err := s.tagRepo.FindByID(ctx, tagID)
        if err != nil </span><span class="cov0" title="0">{
                if errors.Is(err, gorm.ErrRecordNotFound) </span><span class="cov0" title="0">{
                        return nil, 0, ErrTagNotFound
                }</span>
                <span class="cov0" title="0">return nil, 0, err</span>
        }

        <span class="cov0" title="0">return s.tagFollowerRepo.ListFollowers(ctx, tagID, page, pageSize)</span>
}

// ユーザーがフォローしているタグ一覧を返す。
func (s *tagService) ListFollowingTags(ctx context.Context, userID string, page, pageSize int) ([]TagListItem, int64, error) <span class="cov0" title="0">{
        if strings.TrimSpace(userID) == "" </span><span class="cov0" title="0">{
                return nil, 0, fmt.Errorf("user_id is required")
        }</span>
        <span class="cov0" title="0">if page &lt; 1 </span><span class="cov0" title="0">{
                page = 1
        }</span>
        <span class="cov0" title="0">if pageSize &lt;= 0 </span><span class="cov0" title="0">{
                pageSize = 20
        }</span>
        <span class="cov0" title="0">if pageSize &gt; 100 </span><span class="cov0" title="0">{
                pageSize = 100
        }</span>

        <span class="cov0" title="0">tags, total, err := s.tagFollowerRepo.ListFollowingTags(ctx, userID, page, pageSize)
        if err != nil </span><span class="cov0" title="0">{
                return nil, 0, err
        }</span>
        <span class="cov0" title="0">if total == 0 </span><span class="cov0" title="0">{
                return []TagListItem{}, 0, nil
        }</span>

        // 映画ポスター画像の取得
        <span class="cov0" title="0">imagesByTag := make(map[string][]string, len(tags))
        if s.movieService != nil </span><span class="cov0" title="0">{
                for _, tag := range tags </span><span class="cov0" title="0">{
                        tagMovies, err := s.tagMovieRepo.ListRecentByTag(ctx, tag.ID, 4)
                        if err != nil </span><span class="cov0" title="0">{
                                continue</span>
                        }

                        <span class="cov0" title="0">for _, tm := range tagMovies </span><span class="cov0" title="0">{
                                if len(imagesByTag[tag.ID]) &gt;= 4 </span><span class="cov0" title="0">{
                                        break</span>
                                }
                                <span class="cov0" title="0">cache, err := s.movieService.EnsureMovieCache(ctx, tm.TmdbMovieID)
                                if err != nil </span><span class="cov0" title="0">{
                                        continue</span>
                                }
                                <span class="cov0" title="0">if cache.PosterPath == nil || *cache.PosterPath == "" </span><span class="cov0" title="0">{
                                        continue</span>
                                }
                                <span class="cov0" title="0">poster := *cache.PosterPath
                                if s.imageBaseURL != "" </span><span class="cov0" title="0">{
                                        poster = s.imageBaseURL + poster
                                }</span>
                                <span class="cov0" title="0">imagesByTag[tag.ID] = append(imagesByTag[tag.ID], poster)</span>
                        }
                }
        }

        // タグ作成者の情報を取得するため、リポジトリからユーザー情報を取得
        <span class="cov0" title="0">items := make([]TagListItem, 0, len(tags))
        for _, tag := range tags </span><span class="cov0" title="0">{
                // タグ作成者の情報を取得
                author := ""
                authorDisplayID := ""
                if tagDetail, err := s.tagRepo.FindDetailByID(ctx, tag.ID); err == nil </span><span class="cov0" title="0">{
                        author = tagDetail.OwnerDisplayName
                        authorDisplayID = tagDetail.OwnerDisplayID
                }</span>

                <span class="cov0" title="0">item := TagListItem{
                        ID:              tag.ID,
                        Title:           tag.Title,
                        Description:     tag.Description,
                        Author:          author,
                        AuthorDisplayID: authorDisplayID,
                        CoverImageURL:   tag.CoverImageURL,
                        IsPublic:        tag.IsPublic,
                        MovieCount:      tag.MovieCount,
                        FollowerCount:   tag.FollowerCount,
                        Images:          imagesByTag[tag.ID],
                        CreatedAt:       tag.CreatedAt,
                }
                items = append(items, item)</span>
        }

        <span class="cov0" title="0">return items, total, nil</span>
}
</pre>
		
		<pre class="file" id="file30" style="display: none">package service

import (
        "context"
        "errors"
        "fmt"
        "log/slog"
        "strings"
        "time"

        "cinetag-backend/src/internal/model"
        "cinetag-backend/src/internal/repository"

        "gorm.io/gorm"
)

// Clerk 側のユーザー情報のうち、
// - バックエンドが users テーブル同期に利用する最小限の情報を表す構造体。
type ClerkUserInfo struct {
        ID        string  // Clerk の user ID
        Email     string  // メールアドレス
        FirstName string  // 名（任意）
        LastName  string  // 姓（任意）
        AvatarURL *string // アイコンURL（任意）
}

// ユーザーが見つからなかった場合のエラー。
var ErrUserNotFound = errors.New("user not found")

// 自分自身をフォローしようとした場合のエラー。
var ErrCannotFollowSelf = errors.New("cannot follow yourself")

// 既にフォロー済みの場合のエラー。
var ErrAlreadyFollowing = errors.New("already following")

// フォローしていないユーザーをアンフォローしようとした場合のエラー。
var ErrNotFollowing = errors.New("not following")

// users テーブルに関するユースケースを表すインターフェース。
type UserService interface {
        // Clerk ユーザー情報をもとに、
        // users テーブル上に対応するレコードが存在することを保証する。
        // - 既に存在すればそれを返し、存在しなければ新規作成して返す。
        EnsureUser(ctx context.Context, clerkUser ClerkUserInfo) (*model.User, error)

        // clerk_user_id からユーザー情報を取得する。
        // - 削除済みユーザーも取得対象とする（必要に応じて呼び出し側で扱いを決める）。
        FindUserByClerkUserID(ctx context.Context, clerkUserID string) (*model.User, error)

        // display_id からユーザー情報を取得する。
        GetUserByDisplayID(ctx context.Context, displayID string) (*model.User, error)

        // 指定ユーザーをフォローする。
        FollowUser(ctx context.Context, followerID, followeeID string) error

        // 指定ユーザーをアンフォローする。
        UnfollowUser(ctx context.Context, followerID, followeeID string) error

        // followerID が followeeID をフォローしているかチェックする。
        IsFollowing(ctx context.Context, followerID, followeeID string) (bool, error)

        // 指定ユーザーがフォローしているユーザー一覧を取得する。
        ListFollowing(ctx context.Context, userID string, page, pageSize int) ([]*model.User, int64, error)

        // 指定ユーザーをフォローしているユーザー一覧を取得する。
        ListFollowers(ctx context.Context, userID string, page, pageSize int) ([]*model.User, int64, error)

        // フォロー数とフォロワー数を取得する。
        GetFollowStats(ctx context.Context, userID string) (following int64, followers int64, err error)

        // ユーザーを論理削除＋匿名化し、関連データをクリーンアップする。
        DeactivateUser(ctx context.Context, userID string) error
}

type userService struct {
        logger          *slog.Logger
        db               *gorm.DB
        userRepo         repository.UserRepository
        userFollowerRepo repository.UserFollowerRepository
        tagFollowerRepo  repository.TagFollowerRepository
}

// UserService の実装を生成する。
func NewUserService(logger *slog.Logger, db *gorm.DB, userRepo repository.UserRepository, userFollowerRepo repository.UserFollowerRepository, tagFollowerRepo repository.TagFollowerRepository) UserService <span class="cov8" title="1">{
        return &amp;userService{
                logger:          logger,
                db:               db,
                userRepo:         userRepo,
                userFollowerRepo: userFollowerRepo,
                tagFollowerRepo:  tagFollowerRepo,
        }
}</span>

// Clerk ユーザーに対応する users レコードの存在を保証する。
func (s *userService) EnsureUser(ctx context.Context, clerkInfo ClerkUserInfo) (*model.User, error) <span class="cov8" title="1">{
        // 開始ログ（DEBUG）
        s.logger.Debug("service.EnsureUser started",
                slog.String("clerk_user_id", clerkInfo.ID),
        )
        if clerkInfo.ID == "" </span><span class="cov8" title="1">{
                return nil, errors.New("clerk user id is required")
        }</span>
        <span class="cov8" title="1">if strings.TrimSpace(clerkInfo.Email) == "" </span><span class="cov8" title="1">{
                return nil, errors.New("email is required")
        }</span>

        <span class="cov8" title="1">existing, err := s.userRepo.FindByClerkUserID(ctx, clerkInfo.ID)

        switch </span>{
        case err == nil:<span class="cov8" title="1">
                // 既に存在する場合はそのまま返す
                return existing, nil</span>
        case !errors.Is(err, gorm.ErrRecordNotFound):<span class="cov8" title="1">
                // それ以外のエラーはそのまま返す
                return nil, err</span>
        }

        <span class="cov8" title="1">displayName := resolveDisplayName(clerkInfo)

        // display_id はランダム生成（重複したら内部で再生成）
        displayID := GenerateUserDisplayID(ctx, s.userRepo)

        user := &amp;model.User{
                ClerkUserID: clerkInfo.ID,
                DisplayID:   displayID,
                DisplayName: displayName,
                Email:       clerkInfo.Email,
                AvatarURL:   clerkInfo.AvatarURL,
        }

        if err := s.userRepo.Create(ctx, user); err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>

        <span class="cov8" title="1">return user, nil</span>
}

// clerk_user_id からユーザー情報を取得する。
func (s *userService) FindUserByClerkUserID(ctx context.Context, clerkUserID string) (*model.User, error) <span class="cov0" title="0">{
        clerkUserID = strings.TrimSpace(clerkUserID)
        if clerkUserID == "" </span><span class="cov0" title="0">{
                return nil, errors.New("clerk user id is required")
        }</span>

        <span class="cov0" title="0">u, err := s.userRepo.FindByClerkUserID(ctx, clerkUserID)
        if err != nil </span><span class="cov0" title="0">{
                if errors.Is(err, gorm.ErrRecordNotFound) </span><span class="cov0" title="0">{
                        return nil, ErrUserNotFound
                }</span>
                <span class="cov0" title="0">return nil, err</span>
        }
        <span class="cov0" title="0">return u, nil</span>
}

// ユーザー名を解決する。
// - FirstName と LastName が両方存在する場合は FirstName + LastName を返す。
// - FirstName が存在する場合は FirstName を返す。
// - LastName が存在する場合は LastName を返す。
// - どちらも存在しない場合は "名無し" を返す。
func resolveDisplayName(clerkInfo ClerkUserInfo) string <span class="cov8" title="1">{
        first := strings.TrimSpace(clerkInfo.FirstName)
        last := strings.TrimSpace(clerkInfo.LastName)
        switch </span>{
        case first != "" &amp;&amp; last != "":<span class="cov8" title="1">
                return first + " " + last</span>
        case first != "":<span class="cov0" title="0">
                return first</span>
        case last != "":<span class="cov0" title="0">
                return last</span>
        }

        <span class="cov8" title="1">return "名無し"</span>
}

// display_id からユーザー情報を取得する。
func (s *userService) GetUserByDisplayID(ctx context.Context, displayID string) (*model.User, error) <span class="cov0" title="0">{
        // 開始ログ（DEBUG）
        s.logger.Debug("service.GetUserByDisplayID started",
                slog.String("display_id", displayID),
        )
        if displayID == "" </span><span class="cov0" title="0">{
                return nil, errors.New("display_id is required")
        }</span>

        <span class="cov0" title="0">user, err := s.userRepo.FindByDisplayID(ctx, displayID)
        if err != nil </span><span class="cov0" title="0">{
                if errors.Is(err, gorm.ErrRecordNotFound) </span><span class="cov0" title="0">{
                        return nil, ErrUserNotFound
                }</span>
                <span class="cov0" title="0">return nil, err</span>
        }
        <span class="cov0" title="0">if user != nil &amp;&amp; user.DeletedAt != nil </span><span class="cov0" title="0">{
                return nil, ErrUserNotFound
        }</span>

        <span class="cov0" title="0">return user, nil</span>
}

// 指定ユーザーをフォローする。
func (s *userService) FollowUser(ctx context.Context, followerID, followeeID string) error <span class="cov0" title="0">{
        // 開始ログ（DEBUG）
        s.logger.Debug("service.FollowUser started",
                slog.String("follower_id", followerID),
                slog.String("followee_id", followeeID),
        )
        if followerID == "" || followeeID == "" </span><span class="cov0" title="0">{
                return errors.New("follower_id and followee_id are required")
        }</span>

        <span class="cov0" title="0">if followerID == followeeID </span><span class="cov0" title="0">{
                return ErrCannotFollowSelf
        }</span>

        // フォロー対象のユーザーが存在するか確認
        <span class="cov0" title="0">followee, err := s.userRepo.FindByID(ctx, followeeID)
        if err != nil </span><span class="cov0" title="0">{
                if errors.Is(err, gorm.ErrRecordNotFound) </span><span class="cov0" title="0">{
                        return ErrUserNotFound
                }</span>
                <span class="cov0" title="0">return err</span>
        }
        <span class="cov0" title="0">if followee != nil &amp;&amp; followee.DeletedAt != nil </span><span class="cov0" title="0">{
                return ErrUserNotFound
        }</span>

        // 既にフォロー済みかチェック
        <span class="cov0" title="0">isFollowing, err := s.userFollowerRepo.IsFollowing(ctx, followerID, followeeID)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">if isFollowing </span><span class="cov0" title="0">{
                return ErrAlreadyFollowing
        }</span>

        <span class="cov0" title="0">return s.userFollowerRepo.Create(ctx, followerID, followeeID)</span>
}

// 指定ユーザーをアンフォローする。
func (s *userService) UnfollowUser(ctx context.Context, followerID, followeeID string) error <span class="cov0" title="0">{
        if followerID == "" || followeeID == "" </span><span class="cov0" title="0">{
                return errors.New("follower_id and followee_id are required")
        }</span>

        // フォローしているかチェック
        <span class="cov0" title="0">isFollowing, err := s.userFollowerRepo.IsFollowing(ctx, followerID, followeeID)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">if !isFollowing </span><span class="cov0" title="0">{
                return ErrNotFollowing
        }</span>

        <span class="cov0" title="0">return s.userFollowerRepo.Delete(ctx, followerID, followeeID)</span>
}

// followerID が followeeID をフォローしているかチェックする。
func (s *userService) IsFollowing(ctx context.Context, followerID, followeeID string) (bool, error) <span class="cov0" title="0">{
        if followerID == "" || followeeID == "" </span><span class="cov0" title="0">{
                return false, nil
        }</span>
        <span class="cov0" title="0">return s.userFollowerRepo.IsFollowing(ctx, followerID, followeeID)</span>
}

// 指定ユーザーがフォローしているユーザー一覧を取得する。
func (s *userService) ListFollowing(ctx context.Context, userID string, page, pageSize int) ([]*model.User, int64, error) <span class="cov0" title="0">{
        if userID == "" </span><span class="cov0" title="0">{
                return nil, 0, errors.New("user_id is required")
        }</span>
        <span class="cov0" title="0">if page &lt; 1 </span><span class="cov0" title="0">{
                page = 1
        }</span>
        <span class="cov0" title="0">if pageSize &lt; 1 || pageSize &gt; 100 </span><span class="cov0" title="0">{
                pageSize = 20
        }</span>
        <span class="cov0" title="0">return s.userFollowerRepo.ListFollowing(ctx, userID, page, pageSize)</span>
}

// 指定ユーザーをフォローしているユーザー一覧を取得する。
func (s *userService) ListFollowers(ctx context.Context, userID string, page, pageSize int) ([]*model.User, int64, error) <span class="cov0" title="0">{
        if userID == "" </span><span class="cov0" title="0">{
                return nil, 0, errors.New("user_id is required")
        }</span>
        <span class="cov0" title="0">if page &lt; 1 </span><span class="cov0" title="0">{
                page = 1
        }</span>
        <span class="cov0" title="0">if pageSize &lt; 1 || pageSize &gt; 100 </span><span class="cov0" title="0">{
                pageSize = 20
        }</span>
        <span class="cov0" title="0">return s.userFollowerRepo.ListFollowers(ctx, userID, page, pageSize)</span>
}

// フォロー数とフォロワー数を取得する。
func (s *userService) GetFollowStats(ctx context.Context, userID string) (following int64, followers int64, err error) <span class="cov0" title="0">{
        if userID == "" </span><span class="cov0" title="0">{
                return 0, 0, errors.New("user_id is required")
        }</span>

        <span class="cov0" title="0">following, err = s.userFollowerRepo.CountFollowing(ctx, userID)
        if err != nil </span><span class="cov0" title="0">{
                return 0, 0, err
        }</span>

        <span class="cov0" title="0">followers, err = s.userFollowerRepo.CountFollowers(ctx, userID)
        if err != nil </span><span class="cov0" title="0">{
                return 0, 0, err
        }</span>

        <span class="cov0" title="0">return following, followers, nil</span>
}

// ユーザーを、DB側で論理削除＋匿名化し、関連データをクリーンアップする。
func (s *userService) DeactivateUser(ctx context.Context, userID string) error <span class="cov0" title="0">{
        userID = strings.TrimSpace(userID)
        if userID == "" </span><span class="cov0" title="0">{
                return errors.New("user id is required")
        }</span>
        <span class="cov0" title="0">if s.db == nil </span><span class="cov0" title="0">{
                return errors.New("db is required")
        }</span>

        <span class="cov0" title="0">now := time.Now()

        return s.db.WithContext(ctx).Transaction(func(tx *gorm.DB) error </span><span class="cov0" title="0">{
                userRepo := repository.NewUserRepository(s.logger, tx)
                userFollowerRepo := repository.NewUserFollowerRepository(tx)
                tagFollowerRepo := repository.NewTagFollowerRepository(tx)

                u, err := userRepo.FindByID(ctx, userID)
                if err != nil </span><span class="cov0" title="0">{
                        if errors.Is(err, gorm.ErrRecordNotFound) </span><span class="cov0" title="0">{
                                return ErrUserNotFound
                        }</span>
                        <span class="cov0" title="0">return err</span>
                }

                // ユーザーを論理削除＋匿名化
                <span class="cov0" title="0">anonymizedEmail := fmt.Sprintf("deleted+%s@example.invalid", u.ID)
                if err := userRepo.UpdateForUserDeactivated(ctx, u.ID, now, anonymizedEmail); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

                // 当該ユーザーに紐づくフォロー関係をクリーンアップ
                <span class="cov0" title="0">if err := tagFollowerRepo.DeleteAllByUserID(ctx, u.ID); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov0" title="0">if err := userFollowerRepo.DeleteAllByUserID(ctx, u.ID); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

                <span class="cov0" title="0">return nil</span>
        })
}
</pre>
		
		<pre class="file" id="file31" style="display: none">package testutil

import (
        "context"

        "cinetag-backend/src/internal/model"
        "cinetag-backend/src/internal/repository"
)

// FakeTagRepository は repository.TagRepository の手書き fake です。
// 必要なテストで Fn を差し替えて使います。
type FakeTagRepository struct {
        CreateFn              func(ctx context.Context, tag *model.Tag) error
        FindByIDFn            func(ctx context.Context, id string) (*model.Tag, error)
        FindDetailByIDFn      func(ctx context.Context, id string) (*repository.TagDetailRow, error)
        UpdateByIDFn          func(ctx context.Context, id string, patch repository.TagUpdatePatch) error
        IncrementMovieCountFn func(ctx context.Context, id string, delta int) error
        ListPublicTagsFn      func(ctx context.Context, filter repository.TagListFilter) ([]repository.TagSummary, int64, error)
        ListTagsByUserIDFn    func(ctx context.Context, filter repository.UserTagListFilter) ([]repository.TagSummary, int64, error)
}

func (f *FakeTagRepository) Create(ctx context.Context, tag *model.Tag) error <span class="cov0" title="0">{
        if f.CreateFn == nil </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov0" title="0">return f.CreateFn(ctx, tag)</span>
}

func (f *FakeTagRepository) FindByID(ctx context.Context, id string) (*model.Tag, error) <span class="cov0" title="0">{
        if f.FindByIDFn == nil </span><span class="cov0" title="0">{
                return nil, nil
        }</span>
        <span class="cov0" title="0">return f.FindByIDFn(ctx, id)</span>
}

func (f *FakeTagRepository) FindDetailByID(ctx context.Context, id string) (*repository.TagDetailRow, error) <span class="cov0" title="0">{
        if f.FindDetailByIDFn == nil </span><span class="cov0" title="0">{
                return nil, nil
        }</span>
        <span class="cov0" title="0">return f.FindDetailByIDFn(ctx, id)</span>
}

func (f *FakeTagRepository) UpdateByID(ctx context.Context, id string, patch repository.TagUpdatePatch) error <span class="cov0" title="0">{
        if f.UpdateByIDFn == nil </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov0" title="0">return f.UpdateByIDFn(ctx, id, patch)</span>
}

func (f *FakeTagRepository) IncrementMovieCount(ctx context.Context, id string, delta int) error <span class="cov0" title="0">{
        if f.IncrementMovieCountFn == nil </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov0" title="0">return f.IncrementMovieCountFn(ctx, id, delta)</span>
}

func (f *FakeTagRepository) ListPublicTags(ctx context.Context, filter repository.TagListFilter) ([]repository.TagSummary, int64, error) <span class="cov0" title="0">{
        if f.ListPublicTagsFn == nil </span><span class="cov0" title="0">{
                return []repository.TagSummary{}, 0, nil
        }</span>
        <span class="cov0" title="0">return f.ListPublicTagsFn(ctx, filter)</span>
}

func (f *FakeTagRepository) ListTagsByUserID(ctx context.Context, filter repository.UserTagListFilter) ([]repository.TagSummary, int64, error) <span class="cov0" title="0">{
        if f.ListTagsByUserIDFn == nil </span><span class="cov0" title="0">{
                return []repository.TagSummary{}, 0, nil
        }</span>
        <span class="cov0" title="0">return f.ListTagsByUserIDFn(ctx, filter)</span>
}

// FakeTagMovieRepository は repository.TagMovieRepository の手書き fake です。
type FakeTagMovieRepository struct {
        ListRecentByTagFn       func(ctx context.Context, tagID string, limit int) ([]model.TagMovie, error)
        ListByTagFn             func(ctx context.Context, tagID string, offset, limit int) ([]repository.TagMovieWithCache, int64, error)
        CreateFn                func(ctx context.Context, tagMovie *model.TagMovie) error
        FindByIDFn              func(ctx context.Context, tagMovieID string) (*model.TagMovie, error)
        DeleteFn                func(ctx context.Context, tagMovieID string) error
        ListContributorsByTagFn func(ctx context.Context, tagID string, ownerID string, limit int) ([]repository.TagContributor, int64, error)
}

func (f *FakeTagMovieRepository) ListContributorsByTag(ctx context.Context, tagID string, ownerID string, limit int) ([]repository.TagContributor, int64, error) <span class="cov0" title="0">{
        if f.ListContributorsByTagFn == nil </span><span class="cov0" title="0">{
                return []repository.TagContributor{}, 0, nil
        }</span>
        <span class="cov0" title="0">return f.ListContributorsByTagFn(ctx, tagID, ownerID, limit)</span>
}

func (f *FakeTagMovieRepository) ListRecentByTag(ctx context.Context, tagID string, limit int) ([]model.TagMovie, error) <span class="cov0" title="0">{
        if f.ListRecentByTagFn == nil </span><span class="cov0" title="0">{
                return []model.TagMovie{}, nil
        }</span>
        <span class="cov0" title="0">return f.ListRecentByTagFn(ctx, tagID, limit)</span>
}

func (f *FakeTagMovieRepository) ListByTag(ctx context.Context, tagID string, offset, limit int) ([]repository.TagMovieWithCache, int64, error) <span class="cov0" title="0">{
        if f.ListByTagFn == nil </span><span class="cov0" title="0">{
                return []repository.TagMovieWithCache{}, 0, nil
        }</span>
        <span class="cov0" title="0">return f.ListByTagFn(ctx, tagID, offset, limit)</span>
}

func (f *FakeTagMovieRepository) Create(ctx context.Context, tagMovie *model.TagMovie) error <span class="cov0" title="0">{
        if f.CreateFn == nil </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov0" title="0">return f.CreateFn(ctx, tagMovie)</span>
}

func (f *FakeTagMovieRepository) FindByID(ctx context.Context, tagMovieID string) (*model.TagMovie, error) <span class="cov0" title="0">{
        if f.FindByIDFn == nil </span><span class="cov0" title="0">{
                return nil, nil
        }</span>
        <span class="cov0" title="0">return f.FindByIDFn(ctx, tagMovieID)</span>
}

func (f *FakeTagMovieRepository) Delete(ctx context.Context, tagMovieID string) error <span class="cov0" title="0">{
        if f.DeleteFn == nil </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov0" title="0">return f.DeleteFn(ctx, tagMovieID)</span>
}

// FakeTagFollowerRepository は repository.TagFollowerRepository の手書き fake です。
type FakeTagFollowerRepository struct {
        CreateFn            func(ctx context.Context, tagID, userID string) error
        DeleteFn            func(ctx context.Context, tagID, userID string) error
        DeleteAllByUserIDFn func(ctx context.Context, userID string) error
        IsFollowingFn       func(ctx context.Context, tagID, userID string) (bool, error)
        ListFollowersFn     func(ctx context.Context, tagID string, page, pageSize int) ([]*model.User, int64, error)
        CountFollowersFn    func(ctx context.Context, tagID string) (int64, error)
        ListFollowingTagsFn func(ctx context.Context, userID string, page, pageSize int) ([]*model.Tag, int64, error)
}

func (f *FakeTagFollowerRepository) Create(ctx context.Context, tagID, userID string) error <span class="cov0" title="0">{
        if f.CreateFn == nil </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov0" title="0">return f.CreateFn(ctx, tagID, userID)</span>
}

func (f *FakeTagFollowerRepository) Delete(ctx context.Context, tagID, userID string) error <span class="cov0" title="0">{
        if f.DeleteFn == nil </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov0" title="0">return f.DeleteFn(ctx, tagID, userID)</span>
}

func (f *FakeTagFollowerRepository) DeleteAllByUserID(ctx context.Context, userID string) error <span class="cov0" title="0">{
        if f.DeleteAllByUserIDFn == nil </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov0" title="0">return f.DeleteAllByUserIDFn(ctx, userID)</span>
}

func (f *FakeTagFollowerRepository) IsFollowing(ctx context.Context, tagID, userID string) (bool, error) <span class="cov0" title="0">{
        if f.IsFollowingFn == nil </span><span class="cov0" title="0">{
                return false, nil
        }</span>
        <span class="cov0" title="0">return f.IsFollowingFn(ctx, tagID, userID)</span>
}

func (f *FakeTagFollowerRepository) ListFollowers(ctx context.Context, tagID string, page, pageSize int) ([]*model.User, int64, error) <span class="cov0" title="0">{
        if f.ListFollowersFn == nil </span><span class="cov0" title="0">{
                return []*model.User{}, 0, nil
        }</span>
        <span class="cov0" title="0">return f.ListFollowersFn(ctx, tagID, page, pageSize)</span>
}

func (f *FakeTagFollowerRepository) CountFollowers(ctx context.Context, tagID string) (int64, error) <span class="cov0" title="0">{
        if f.CountFollowersFn == nil </span><span class="cov0" title="0">{
                return 0, nil
        }</span>
        <span class="cov0" title="0">return f.CountFollowersFn(ctx, tagID)</span>
}

func (f *FakeTagFollowerRepository) ListFollowingTags(ctx context.Context, userID string, page, pageSize int) ([]*model.Tag, int64, error) <span class="cov0" title="0">{
        if f.ListFollowingTagsFn == nil </span><span class="cov0" title="0">{
                return []*model.Tag{}, 0, nil
        }</span>
        <span class="cov0" title="0">return f.ListFollowingTagsFn(ctx, userID, page, pageSize)</span>
}
</pre>
		
		<pre class="file" id="file32" style="display: none">package testutil

import (
        "context"

        "cinetag-backend/src/internal/model"
)

// FakeMovieService は service.MovieService の最小 fake（必要なメソッドのみ）です。
// 使うテストで必要になったら拡張します。
//
// NOTE: 現時点で TagService は MovieService を interface として受け取っているため、
// テストでは nil を渡して非同期処理（キャッシュ温め）を発火させない運用が基本です。
type FakeMovieService struct {
        EnsureMovieCacheFn func(ctx context.Context, tmdbMovieID int) (*model.MovieCache, error)
}

func (f *FakeMovieService) EnsureMovieCache(ctx context.Context, tmdbMovieID int) (*model.MovieCache, error) <span class="cov0" title="0">{
        if f.EnsureMovieCacheFn == nil </span><span class="cov0" title="0">{
                return &amp;model.MovieCache{}, nil
        }</span>
        <span class="cov0" title="0">return f.EnsureMovieCacheFn(ctx, tmdbMovieID)</span>
}
</pre>
		
		<pre class="file" id="file33" style="display: none">package testutil

import (
        "bytes"
        "io"
        "log/slog"
        "net/http"
        "net/http/httptest"
        "os"

        "github.com/gin-gonic/gin"
)

// NewTestRouter は Gin をテスト用設定で初期化して返します。
// テスト側で必要なルーティングを登録して使います。
func NewTestRouter() *gin.Engine <span class="cov0" title="0">{
        gin.SetMode(gin.TestMode)
        return gin.New()
}</span>

// NewTestLogger はテスト用のロガーを返します。
// 出力は os.Stderr に送られますが、通常はテスト中は表示されません。
func NewTestLogger() *slog.Logger <span class="cov0" title="0">{
        handler := slog.NewTextHandler(os.Stderr, &amp;slog.HandlerOptions{
                Level: slog.LevelDebug,
        })
        return slog.New(handler)
}</span>

// PerformRequest は http.Handler に対して疑似リクエストを実行し、レスポンスを返します。
func PerformRequest(h http.Handler, method, path string, body []byte, headers map[string]string) *httptest.ResponseRecorder <span class="cov0" title="0">{
        var r io.Reader
        if body != nil </span><span class="cov0" title="0">{
                r = bytes.NewReader(body)
        }</span>
        <span class="cov0" title="0">req := httptest.NewRequest(method, path, r)
        for k, v := range headers </span><span class="cov0" title="0">{
                req.Header.Set(k, v)
        }</span>
        <span class="cov0" title="0">rw := httptest.NewRecorder()
        h.ServeHTTP(rw, req)
        return rw</span>
}
</pre>
		
		<pre class="file" id="file34" style="display: none">package testutil

import (
        "encoding/json"
        "testing"
)

// MustMarshalJSON は v を JSON に変換し、失敗したらテストを落とします。
func MustMarshalJSON(t *testing.T, v any) []byte <span class="cov0" title="0">{
        t.Helper()
        b, err := json.Marshal(v)
        if err != nil </span><span class="cov0" title="0">{
                t.Fatalf("failed to marshal json: %v", err)
        }</span>
        <span class="cov0" title="0">return b</span>
}

// MustUnmarshalJSON は JSON を dst に詰め、失敗したらテストを落とします。
func MustUnmarshalJSON(t *testing.T, b []byte, dst any) <span class="cov0" title="0">{
        t.Helper()
        if err := json.Unmarshal(b, dst); err != nil </span><span class="cov0" title="0">{
                t.Fatalf("failed to unmarshal json: %v", err)
        }</span>
}
</pre>
		
		<pre class="file" id="file35" style="display: none">package router

import (
        "log/slog"
        "os"

        "cinetag-backend/src/internal/db"
        "cinetag-backend/src/internal/handler"
        "cinetag-backend/src/internal/logger"
        "cinetag-backend/src/internal/middleware"
        "cinetag-backend/src/internal/repository"
        "cinetag-backend/src/internal/service"

        "github.com/gin-gonic/gin"
)

// Dependencies はアプリケーションの依存関係をまとめた構造体です。
type Dependencies struct {
        // Logger は構造化ロガーです。
        Logger *slog.Logger

        // Handlers
        TagHandler          *handler.TagHandler
        MovieHandler        *handler.MovieHandler
        UserHandler         *handler.UserHandler
        ClerkWebhookHandler *handler.ClerkWebhookHandler

        // Middlewares
        RequestLoggerMiddleware gin.HandlerFunc
        RecoveryMiddleware      gin.HandlerFunc
        AuthMiddleware          gin.HandlerFunc
        OptionalAuthMiddleware  gin.HandlerFunc
}

// NewDependencies はアプリケーションの依存関係を組み立てて返します。
func NewDependencies() *Dependencies <span class="cov0" title="0">{
        // Logger の初期化
        log := logger.NewLogger()

        // Database
        database := db.NewDB()

        // Repositories
        tagRepo := repository.NewTagRepository(database)
        tagMovieRepo := repository.NewTagMovieRepository(database)
        tagFollowerRepo := repository.NewTagFollowerRepository(database)
        userRepo := repository.NewUserRepository(log, database)
        userFollowerRepo := repository.NewUserFollowerRepository(database)

        // Services
        movieService := service.NewMovieService(log, database)
        imageBaseURL := os.Getenv("TMDB_IMAGE_BASE_URL")
        tagService := service.NewTagService(log, tagRepo, tagMovieRepo, tagFollowerRepo, movieService, imageBaseURL)
        userService := service.NewUserService(log, database, userRepo, userFollowerRepo, tagFollowerRepo)

        // Handlers
        tagHandler := handler.NewTagHandler(log, tagService)
        movieHandler := handler.NewMovieHandler(log, movieService)
        userHandler := handler.NewUserHandler(log, userService, tagService)
        clerkWebhookHandler := handler.NewClerkWebhookHandler(log, userService)

        // Middlewares
        requestLoggerMiddleware := middleware.NewRequestLoggerMiddleware(log)
        recoveryMiddleware := middleware.NewRecoveryMiddleware(log)
        authMiddleware := middleware.NewAuthMiddleware(log, userService)
        optionalAuthMiddleware := middleware.NewOptionalAuthMiddleware(log, userService)

        return &amp;Dependencies{
                Logger:                  log,
                TagHandler:              tagHandler,
                MovieHandler:            movieHandler,
                UserHandler:             userHandler,
                ClerkWebhookHandler:     clerkWebhookHandler,
                RequestLoggerMiddleware: requestLoggerMiddleware,
                RecoveryMiddleware:      recoveryMiddleware,
                AuthMiddleware:          authMiddleware,
                OptionalAuthMiddleware:  optionalAuthMiddleware,
        }
}</span>
</pre>
		
		<pre class="file" id="file36" style="display: none">package router

import (
        "net/http"
        "time"

        "github.com/gin-contrib/cors"
        "github.com/gin-gonic/gin"
        swaggerfiles "github.com/swaggo/files"
        ginSwagger "github.com/swaggo/gin-swagger"
)

func NewRouter() *gin.Engine <span class="cov0" title="0">{
        // gin.Default() の代わりに gin.New() を使用し、
        // カスタムのロガーとリカバリーミドルウェアを適用
        r := gin.New()

        // 依存関係の組み立て
        deps := NewDependencies()

        // ミドルウェア設定（ログとリカバリーを含む）
        setupMiddleware(r, deps)

        // ルート設定
        setupRoutes(r, deps)

        return r
}</span>

// setupMiddleware はミドルウェアを設定します。
func setupMiddleware(r *gin.Engine, deps *Dependencies) <span class="cov0" title="0">{
        // リカバリーミドルウェア（パニック時のログ出力）
        r.Use(deps.RecoveryMiddleware)

        // リクエストログミドルウェア（request_id付与、リクエストログ出力）
        r.Use(deps.RequestLoggerMiddleware)

        // CORS設定
        r.Use(cors.New(cors.Config{
                // 許可するオリジン（開発環境と本番環境のフロントエンドURL）
                AllowOrigins: []string{
                        "http://localhost:3000",                                // ローカル開発環境
                        "http://localhost:8787",                                // ローカル開発環境（Cloudflare Pages プレビュー）
                        "https://cinetag-frontend.yuta-develop-ct.workers.dev", // 開発環境（Cloudflare Workers）
                },
                // 許可するHTTPメソッド
                AllowMethods: []string{"GET", "POST", "PATCH", "DELETE", "OPTIONS"},
                // 許可するリクエストヘッダー（Origin, Content-Type, Authorizationを許可）
                AllowHeaders: []string{"Origin", "Content-Type", "Authorization"},
                // レスポンスでアクセスを許可するヘッダー（Content-Lengthをクライアントに公開）
                ExposeHeaders: []string{"Content-Length"},
                // Cookieなどを含む認証情報のクロスオリジン送信を許可
                AllowCredentials: true,
                // プリフライトリクエスト（OPTIONS）結果のキャッシュ期間（12時間）
                MaxAge: 12 * time.Hour,
        }))
}</span>

// setupRoutes はすべてのルートを設定します。
func setupRoutes(r *gin.Engine, deps *Dependencies) <span class="cov0" title="0">{
        // ヘルスチェック用エンドポイント
        r.GET("/health", healthCheckHandler)

        // Swagger
        r.GET("/swagger/*any", ginSwagger.WrapHandler(swaggerfiles.Handler))

        // API グループ
        api := r.Group("/api/v1")
        </span><span class="cov0" title="0">{
                // Clerk Webhook
                api.POST("/clerk/webhook", deps.ClerkWebhookHandler.HandleWebhook)

                // 公開ルート（認証不要）
                setupPublicRoutes(api, deps)

                // 認証必須ルート
                setupAuthRoutes(api, deps)
        }</span>
}

// setupPublicRoutes は認証不要の公開ルートを設定します。
func setupPublicRoutes(api *gin.RouterGroup, deps *Dependencies) <span class="cov0" title="0">{
        // タグ（公開）
        api.GET("/tags", deps.TagHandler.ListPublicTags)
        api.GET("/tags/:tagId", deps.OptionalAuthMiddleware, deps.TagHandler.GetTagDetail)
        api.GET("/tags/:tagId/movies", deps.OptionalAuthMiddleware, deps.TagHandler.ListTagMovies)
        api.GET("/tags/:tagId/followers", deps.TagHandler.ListTagFollowers)

        // ユーザー（公開）
        api.GET("/users/:displayId", deps.UserHandler.GetUserByDisplayID)
        api.GET("/users/:displayId/tags", deps.OptionalAuthMiddleware, deps.UserHandler.ListUserTags)
        api.GET("/users/:displayId/following", deps.UserHandler.ListFollowing)
        api.GET("/users/:displayId/followers", deps.UserHandler.ListFollowers)
        api.GET("/users/:displayId/follow-stats", deps.OptionalAuthMiddleware, deps.UserHandler.GetUserFollowStats)

        // 映画検索（公開）
        api.GET("/movies/search", deps.MovieHandler.SearchMovies)
}</span>

// setupAuthRoutes は認証必須のルートを設定します。
func setupAuthRoutes(api *gin.RouterGroup, deps *Dependencies) <span class="cov0" title="0">{
        authGroup := api.Group("/")
        authGroup.Use(deps.AuthMiddleware)
        </span><span class="cov0" title="0">{
                // ユーザー
                setupUserRoutes(authGroup, deps)

                // タグ
                setupTagRoutes(authGroup, deps)

                // タグフォロー
                setupTagFollowRoutes(authGroup, deps)

                // 自分のフォロー中タグ一覧
                authGroup.GET("/me/following-tags", deps.TagHandler.ListFollowingTags)
        }</span>
}

// setupUserRoutes はユーザー関連の認証必須ルートを設定します。
func setupUserRoutes(authGroup *gin.RouterGroup, deps *Dependencies) <span class="cov0" title="0">{
        authGroup.GET("/users/me", deps.UserHandler.GetMe)
        authGroup.POST("/users/:displayId/follow", deps.UserHandler.FollowUser)
        authGroup.DELETE("/users/:displayId/follow", deps.UserHandler.UnfollowUser)
}</span>

// setupTagRoutes はタグ関連の認証必須ルートを設定します。
func setupTagRoutes(authGroup *gin.RouterGroup, deps *Dependencies) <span class="cov0" title="0">{
        authGroup.POST("/tags", deps.TagHandler.CreateTag)
        authGroup.PATCH("/tags/:tagId", deps.TagHandler.UpdateTag)
        authGroup.POST("/tags/:tagId/movies", deps.TagHandler.AddMovieToTag)
        authGroup.DELETE("/tags/:tagId/movies/:tagMovieId", deps.TagHandler.RemoveMovieFromTag)
}</span>

// setupTagFollowRoutes はタグフォロー関連の認証必須ルートを設定します。
func setupTagFollowRoutes(authGroup *gin.RouterGroup, deps *Dependencies) <span class="cov0" title="0">{
        authGroup.POST("/tags/:tagId/follow", deps.TagHandler.FollowTag)
        authGroup.DELETE("/tags/:tagId/follow", deps.TagHandler.UnfollowTag)
        authGroup.GET("/tags/:tagId/follow-status", deps.TagHandler.GetTagFollowStatus)
}</span>

// healthCheckHandler はヘルスチェック用のハンドラーです。
func healthCheckHandler(c *gin.Context) <span class="cov0" title="0">{
        c.JSON(http.StatusOK, gin.H{
                "status": "ok",
        })
}</span>
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
